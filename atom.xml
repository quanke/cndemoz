<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全科-不安分的码农</title>
  
  <subtitle>android，ios，html5，微服务架构，XP，scrum，项目管理（PMP）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quanke.name/"/>
  <updated>2018-02-02T15:55:15.000Z</updated>
  <id>http://quanke.name/</id>
  
  <author>
    <name>全科</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的第一个Kotlin应用</title>
    <link href="http://quanke.name/posts/41862/"/>
    <id>http://quanke.name/posts/41862/</id>
    <published>2018-02-02T14:38:51.000Z</published>
    <updated>2018-02-02T15:55:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式学习Kotlin这门语言，学习之前看了很多关于Kotlin的推广文，本来一门新的语言很难普及，有Google站台，心里有底了很多，本人做过Android开发，所以对于Android相关的东西还是比较关注的。</p><p>废话说了这么多，现在正式开始我的第一个Kotlin应用，当然从打印<code>Hello World</code>开始。</p><p><code>Kotlin</code>有多种方式打印<code>Hello World</code>，比如通过命令行、通过应用等。按道理通过命令行打印“Hello World”比较简单，但是我今天不去讲命令行的实现方式，因为在之后的学习中用的很少、而且命令行的形式比较简单。所有我们主要是通过应用的方式去学习。有一些教程使用 <code>gradle</code>去创建项目，我觉得第一个<code>Kotlin</code>应用太麻烦了，怕不懂，所以我今天实现一个极其简单的Kotlin应用。</p><p>我这里用的IDE是<code>Intelli IDEA</code>，亲儿子当然要用，不解释，如果亲一定要用其他的，不好意思，我这里不提供方法，因为我也不会。</p><p>首先安装最新版本的Intelli IDEA，<code>File-&gt;New-&gt;Project</code></p><p><img src="http://upload-images.jianshu.io/upload_images/432952-00d05466821aa9c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建Kotlin项目"></p><p>选择 Kotlin -&gt; Kotlin/JVM</p><p>新建完项目之后，新建<code>HelloWorld.kt</code>类：</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-30f6e3f0910213b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建HelloWorld.kt类"></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.kotlin.helloworld</div><div class="line"></div><div class="line">class HelloWorld &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line">* Created by quanke.name on 2018/1/8.</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">println(&quot;Hello World!&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行后输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure></p><p>到此为止我的第一个Kotlin应用结束了！</p><p>这是<a href="http://quanke.name/spring-boot-with-kotlin-in-action">《Spring Boot in kotlin 实战》</a>的开始篇，欢迎关注！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始正式学习Kotlin这门语言，学习之前看了很多关于Kotlin的推广文，本来一门新的语言很难普及，有Google站台，心里有底了很多，本人做过Android开发，所以对于Android相关的东西还是比较关注的。&lt;/p&gt;
&lt;p&gt;废话说了这么多，现在正式开始我的第一个K
      
    
    </summary>
    
      <category term="Spring Boot与kotlin实战" scheme="http://quanke.name/categories/Spring-Boot%E4%B8%8Ekotlin%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="kotlin" scheme="http://quanke.name/tags/kotlin/"/>
    
      <category term="spring boot" scheme="http://quanke.name/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API 搜索之Scrolls(四)</title>
    <link href="http://quanke.name/posts/3267/"/>
    <id>http://quanke.name/posts/3267/</id>
    <published>2017-12-06T14:47:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Using-scrolls-in-Java"><a href="#Using-scrolls-in-Java" class="headerlink" title="Using scrolls in Java"></a>Using scrolls in Java</h3><p>首先需要阅读 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-request-scroll.html" target="_blank" rel="external">scroll documentation</a></p><blockquote><p>一般搜索请求都是返回一”页”数据，无论数据量多大都一起返回给用户，Scroll API可以允许我们检索大量数据（甚至全部数据）。Scroll API允许我们做一个初始阶段搜索并且持续批量从Elasticsearch里拉取结果直到没有结果剩下。这有点像传统数据库里的cursors（游标）。<br>Scroll API的创建并不是为了实时的用户响应，而是为了处理大量的数据（Scrolling is not intended for real time user requests, but rather for processing large amounts of data）。从 scroll 请求返回的结果只是反映了 search 发生那一时刻的索引状态，就像一个快照(The results that are returned from a scroll request reflect the state of the index at the time that the initial search request was made, like a snapshot in time)。后续的对文档的改动（索引、更新或者删除）都只会影响后面的搜索请求。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import static org.elasticsearch.index.query.QueryBuilders.*;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">QueryBuilder qb = termQuery(&quot;multi&quot;, &quot;test&quot;);</div><div class="line"></div><div class="line">SearchResponse scrollResp = client.prepareSearch(test)</div><div class="line">        .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC)</div><div class="line">        .setScroll(new TimeValue(60000)) //为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，告诉 Elasticsearch 需要保持搜索的上下文环境多长时间（滚动时间）</div><div class="line">        .setQuery(qb)</div><div class="line">        .setSize(100).get(); //max of 100 hits will be returned for each scroll</div><div class="line">//Scroll until no hits are returned</div><div class="line">do &#123;</div><div class="line">    for (SearchHit hit : scrollResp.getHits().getHits()) &#123;</div><div class="line">        //Handle the hit...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    scrollResp = client.prepareSearchScroll(scrollResp.getScrollId()).setScroll(new TimeValue(60000)).execute().actionGet();</div><div class="line">&#125; while(scrollResp.getHits().getHits().length != 0); // Zero hits mark the end of the scroll and the while loop.</div></pre></td></tr></table></figure><blockquote><p>如果超过滚动时间，继续使用该滚动ID搜索数据，则会报错：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Caused by: SearchContextMissingException[No search context found for id [2861]]</div><div class="line">at org.elasticsearch.search.SearchService.findContext(SearchService.java:613)</div><div class="line">at org.elasticsearch.search.SearchService.executeQueryPhase(SearchService.java:403)</div><div class="line">at org.elasticsearch.search.action.SearchServiceTransportAction$SearchQueryScrollTransportHandler.messageReceived(SearchServiceTransportAction.java:384)</div><div class="line">at org.elasticsearch.search.action.SearchServiceTransportAction$SearchQueryScrollTransportHandler.messageReceived(SearchServiceTransportAction.java:381)</div><div class="line">at org.elasticsearch.transport.TransportRequestHandler.messageReceived(TransportRequestHandler.java:33)</div><div class="line">at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:75)</div><div class="line">at org.elasticsearch.transport.TransportService$4.doRun(TransportService.java:376)</div><div class="line">at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37)</div><div class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div class="line">at java.lang.Thread.run(Thread.java:745)</div></pre></td></tr></table></figure><blockquote><p>虽然当滚动有效时间已过，搜索上下文(Search Context)会自动被清除，但是一值保持滚动代价也是很大的，所以当我们不在使用滚动时要尽快使用Clear-Scroll API进行清除。</p></blockquote><h2 id="清除Scroll"><a href="#清除Scroll" class="headerlink" title="清除Scroll"></a>清除Scroll</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">   * 清除滚动ID</div><div class="line">   * @param client</div><div class="line">   * @param scrollIdList</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  public static boolean clearScroll(Client client, List&lt;String&gt; scrollIdList)&#123;</div><div class="line">      ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll();</div><div class="line">      clearScrollRequestBuilder.setScrollIds(scrollIdList);</div><div class="line">      ClearScrollResponse response = clearScrollRequestBuilder.get();</div><div class="line">      return response.isSucceeded();</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 清除滚动ID</div><div class="line">   * @param client</div><div class="line">   * @param scrollId</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  public static boolean clearScroll(Client client, String scrollId)&#123;</div><div class="line">      ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll();</div><div class="line">      clearScrollRequestBuilder.addScrollId(scrollId);</div><div class="line">      ClearScrollResponse response = clearScrollRequestBuilder.get();</div><div class="line">      return response.isSucceeded();</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">public class ScrollsAPI extends ElasticsearchClientBase &#123;</div><div class="line"></div><div class="line">    private String scrollId;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testScrolls() throws Exception &#123;</div><div class="line"></div><div class="line">        SearchResponse scrollResp = client.prepareSearch(&quot;twitter&quot;)</div><div class="line">                .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC)</div><div class="line">                .setScroll(new TimeValue(60000)) //为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，告诉 Elasticsearch 需要保持搜索的上下文环境多长时间（滚动时间）</div><div class="line">                .setQuery(QueryBuilders.termQuery(&quot;user&quot;, &quot;kimchy&quot;))                 // Query 查询条件</div><div class="line">                .setSize(5).get(); //max of 100 hits will be returned for each scroll</div><div class="line">        //Scroll until no hits are returned</div><div class="line"></div><div class="line">        scrollId = scrollResp.getScrollId();</div><div class="line">        do &#123;</div><div class="line">            for (SearchHit hit : scrollResp.getHits().getHits()) &#123;</div><div class="line">                //Handle the hit...</div><div class="line"></div><div class="line">                System.out.println(&quot;&quot; + hit.getSource().toString());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            scrollResp = client.prepareSearchScroll(scrollId).setScroll(new TimeValue(60000)).execute().actionGet();</div><div class="line">        &#125;</div><div class="line">        while (scrollResp.getHits().getHits().length != 0); // Zero hits mark the end of the scroll and the while loop.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll();</div><div class="line">        clearScrollRequestBuilder.addScrollId(scrollId);</div><div class="line">        ClearScrollResponse response = clearScrollRequestBuilder.get();</div><div class="line"></div><div class="line">        if (response.isSucceeded()) &#123;</div><div class="line">            System.out.println(&quot;成功清除&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        super.tearDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/search/ScrollsAPI.java" target="_blank" rel="external">ScrollsAPI.java</a></p></li><li><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">本手册完整实例</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Using-scrolls-in-Java&quot;&gt;&lt;a href=&quot;#Using-scrolls-in-Java&quot; class=&quot;headerlink&quot; title=&quot;Using scrolls in Java&quot;&gt;&lt;/a&gt;Using scrolls in Java&lt;/
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API 搜索之简介（三）</title>
    <link href="http://quanke.name/posts/44811/"/>
    <id>http://quanke.name/posts/44811/</id>
    <published>2017-12-06T14:25:00.000Z</published>
    <updated>2018-02-02T15:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch-Java-API-搜索之简介"><a href="#Elasticsearch-Java-API-搜索之简介" class="headerlink" title="Elasticsearch Java API 搜索之简介"></a>Elasticsearch Java API 搜索之简介</h1><p>搜索查询，返回查询匹配的结果，搜索一个index / type 或者多个index / type，可以使用 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/java-query-dsl.html" target="_blank" rel="external">query Java API</a> 作为查询条件，下面是例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.elasticsearch.action.search.SearchResponse;</div><div class="line">import org.elasticsearch.action.search.SearchType;</div><div class="line">import org.elasticsearch.index.query.QueryBuilders.*;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SearchResponse response = client.prepareSearch(&quot;index1&quot;, &quot;index2&quot;)</div><div class="line">        .setTypes(&quot;type1&quot;, &quot;type2&quot;)</div><div class="line">        .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</div><div class="line">        .setQuery(QueryBuilders.termQuery(&quot;multi&quot;, &quot;test&quot;))                 // Query 查询条件</div><div class="line">        .setPostFilter(QueryBuilders.rangeQuery(&quot;age&quot;).from(12).to(18))     // Filter 过滤</div><div class="line">        .setFrom(0).setSize(60).setExplain(true)</div><div class="line">        .get();</div></pre></td></tr></table></figure><p>所有的参数都是可选的，下面是最简单的调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// MatchAll on the whole cluster with all default options</div><div class="line">SearchResponse response = client.prepareSearch().get();</div></pre></td></tr></table></figure><blockquote><p>尽管Java API默认提供<code>QUERY_AND_FETCH</code> 和 <code>DFS_QUERY_AND_FETCH</code> 两种 search types ，但是这种模式应该由系统选择，用户不要手动指定</p></blockquote><p>更多请移步 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search.html" target="_blank" rel="external">REST search</a> 文档</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Elasticsearch-Java-API-搜索之简介&quot;&gt;&lt;a href=&quot;#Elasticsearch-Java-API-搜索之简介&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch Java API 搜索之简介&quot;&gt;&lt;/a&gt;El
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>多种方式解决spring boot swagger ui使用 nginx 部署后无法使用问题</title>
    <link href="http://quanke.name/posts/21506/"/>
    <id>http://quanke.name/posts/21506/</id>
    <published>2017-12-05T14:19:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p><code>spring boot</code> 使用 <code>swagger ui</code> 做接口文档，很是方便</p><p>本地测试都没有问题</p><p>将一个<code>Spring boot</code>工程部署到生产环境， 配置<code>nginx</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  quanke.name;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:3101;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>浏览器中访问： quanke.name, 选中某一接口点击try it out,显示:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">No Content。</div></pre></td></tr></table></figure><p>Request  URL:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://127.0.0.1:3101/test</div></pre></td></tr></table></figure></p><p>而不是</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://quanke.name/test</div></pre></td></tr></table></figure><p>通过朋友+搜索知道有两种方法解决此问题：</p><h3 id="第一种：修改nginx配置文件"><a href="#第一种：修改nginx配置文件" class="headerlink" title="第一种：修改nginx配置文件"></a>第一种：修改nginx配置文件</h3><p>把<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  quanke.name;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:3101;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  quanke.name;</div><div class="line">    </div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:3101;</div><div class="line">        proxy_set_header Host $host; # 指定host</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="第二种：启动工程时显式添加属性"><a href="#第二种：启动工程时显式添加属性" class="headerlink" title="第二种：启动工程时显式添加属性"></a>第二种：启动工程时显式添加属性</h3><p>Java 启动的时候指定<code>swagger.v2.host</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-Dspringfox.documentation.swagger.v2.host=quanke.name</div></pre></td></tr></table></figure><p>启动命令实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java -jar -Dspringfox.documentation.swagger.v2.host=quanke.name /data/app/quanke/api.jar</div></pre></td></tr></table></figure><p>或者在配置文件（application.properties）中进行配置</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote><p><img src="https://static.oschina.net/uploads/img/201711/08183543_ysUa.jpg" alt="全科的公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;spring boot&lt;/code&gt; 使用 &lt;code&gt;swagg
      
    
    </summary>
    
      <category term="服务端开发" scheme="http://quanke.name/categories/service/"/>
    
    
      <category term="java" scheme="http://quanke.name/tags/java/"/>
    
      <category term="spirng boot" scheme="http://quanke.name/tags/spirng-boot/"/>
    
      <category term="nginx" scheme="http://quanke.name/tags/nginx/"/>
    
      <category term="swagger ui" scheme="http://quanke.name/tags/swagger-ui/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API 索引的增删改查（二）</title>
    <link href="http://quanke.name/posts/51297/"/>
    <id>http://quanke.name/posts/51297/</id>
    <published>2017-11-15T12:10:00.000Z</published>
    <updated>2018-02-02T15:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节介绍以下 CRUD API：</p><p> 单文档  APIs</p><ul><li><a href="document-apis/index-api.md">Index API</a></li><li><a href="document-apis/get-api.md">Get API</a></li><li><a href="document-apis/delete-api.md">Delete API</a></li><li><a href="document-apis/delete-by-query-api.md">Delete By Query API</a></li><li><a href="document-apis/update-api.md">Update API</a></li></ul><p>多文档 APIs</p><ul><li><a href="document-apis/multi-get-api.md">Multi Get API</a></li><li><a href="document-apis/bulk-api.md">Bulk API</a></li><li><a href="document-apis/using-bulk-processor.md">Using Bulk Processor</a></li></ul><p>Multi Get API<br>Bulk API</p><blockquote><p>注意:所有的单文档的CRUD API，index参数只能接受单一的索引库名称，或者是一个指向单一索引库的alias。</p></blockquote><h3 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h3><p>Index API 允许我们存储一个JSON格式的文档，使数据可以被搜索。文档通过index、type、id唯一确定。我们可以自己提供一个id，或者也使用Index API 为我们自动生成一个。</p><p>这里有几种不同的方式来产生JSON格式的文档(document)：</p><ul><li>手动方式，使用原生的byte[]或者String</li><li>使用Map方式，会自动转换成与之等价的JSON</li><li>使用第三方库来序列化beans，如Jackson</li><li>使用内置的帮助类 XContentFactory.jsonBuilder()</li></ul><h4 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/mapping-date-format.html" target="_blank" rel="external">数据格式</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String json = &quot;&#123;&quot; +</div><div class="line">        &quot;\&quot;user\&quot;:\&quot;kimchy\&quot;,&quot; +</div><div class="line">        &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +</div><div class="line">        &quot;\&quot;message\&quot;:\&quot;trying out Elasticsearch\&quot;&quot; +</div><div class="line">    &quot;&#125;&quot;;</div></pre></td></tr></table></figure></p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**  </div><div class="line"> * 手动生成JSON  </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateJSON()&#123;  </div><div class="line">      </div><div class="line">    String json = &quot;&#123;&quot; +  </div><div class="line">            &quot;\&quot;user\&quot;:\&quot;fendo\&quot;,&quot; +  </div><div class="line">            &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +  </div><div class="line">            &quot;\&quot;message\&quot;:\&quot;Hell word\&quot;&quot; +  </div><div class="line">        &quot;&#125;&quot;;  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">            .setSource(json)  </div><div class="line">            .get();  </div><div class="line">    System.out.println(response.getResult());  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Map方式"><a href="#Map方式" class="headerlink" title="Map方式"></a>Map方式</h4><p>Map是key:value数据类型，可以代表json结构.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();</div><div class="line">json.put(&quot;user&quot;,&quot;kimchy&quot;);</div><div class="line">json.put(&quot;postDate&quot;,new Date());</div><div class="line">json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);</div></pre></td></tr></table></figure><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> /**  </div><div class="line"> * 使用集合  </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateList()&#123;  </div><div class="line">      </div><div class="line">    Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();  </div><div class="line">    json.put(&quot;user&quot;,&quot;kimchy&quot;);  </div><div class="line">    json.put(&quot;postDate&quot;,&quot;2013-01-30&quot;);  </div><div class="line">    json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">            .setSource(json)  </div><div class="line">            .get();  </div><div class="line">    System.out.println(response.getResult());  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h4><p>ElasticSearch已经使用了jackson，可以直接使用它把javabean转为json.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.fasterxml.jackson.databind.*;</div><div class="line"></div><div class="line">// instance a json mapper</div><div class="line">ObjectMapper mapper = new ObjectMapper(); // create once, reuse</div><div class="line"></div><div class="line">// generate json</div><div class="line">byte[] json = mapper.writeValueAsBytes(yourbeaninstance);</div></pre></td></tr></table></figure><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**  </div><div class="line"> * 使用JACKSON序列化  </div><div class="line"> * @throws Exception  </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateJACKSON() throws Exception&#123;  </div><div class="line">      </div><div class="line">    CsdnBlog csdn=new CsdnBlog();  </div><div class="line">    csdn.setAuthor(&quot;fendo&quot;);  </div><div class="line">    csdn.setContent(&quot;这是JAVA书籍&quot;);  </div><div class="line">    csdn.setTag(&quot;C&quot;);  </div><div class="line">    csdn.setView(&quot;100&quot;);  </div><div class="line">    csdn.setTitile(&quot;编程&quot;);  </div><div class="line">    csdn.setDate(new Date().toString());  </div><div class="line">      </div><div class="line">    // instance a json mapper  </div><div class="line">    ObjectMapper mapper = new ObjectMapper(); // create once, reuse  </div><div class="line"></div><div class="line">    // generate json  </div><div class="line">    byte[] json = mapper.writeValueAsBytes(csdn);  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">            .setSource(json)  </div><div class="line">            .get();  </div><div class="line">    System.out.println(response.getResult());  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="XContentBuilder帮助类方式"><a href="#XContentBuilder帮助类方式" class="headerlink" title="XContentBuilder帮助类方式"></a>XContentBuilder帮助类方式</h4><p>ElasticSearch提供了一个内置的帮助类XContentBuilder来产生JSON文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Index name</div><div class="line">String _index = response.getIndex();</div><div class="line">// Type name</div><div class="line">String _type = response.getType();</div><div class="line">// Document ID (generated or not)</div><div class="line">String _id = response.getId();</div><div class="line">// Version (if it&apos;s the first time you index this document, you will get: 1)</div><div class="line">long _version = response.getVersion();</div><div class="line">// status has stored current instance statement.</div><div class="line">RestStatus status = response.status();</div></pre></td></tr></table></figure><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**  </div><div class="line"> * 使用ElasticSearch 帮助类  </div><div class="line"> * @throws IOException   </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateXContentBuilder() throws IOException&#123;  </div><div class="line">      </div><div class="line">    XContentBuilder builder = XContentFactory.jsonBuilder()  </div><div class="line">            .startObject()  </div><div class="line">                .field(&quot;user&quot;, &quot;ccse&quot;)  </div><div class="line">                .field(&quot;postDate&quot;, new Date())  </div><div class="line">                .field(&quot;message&quot;, &quot;this is Elasticsearch&quot;)  </div><div class="line">            .endObject();  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodata&quot;).setSource(builder).get();  </div><div class="line">    System.out.println(&quot;创建成功!&quot;);  </div><div class="line">      </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> </div><div class="line">import java.io.IOException;  </div><div class="line">import java.net.InetAddress;  </div><div class="line">import java.net.UnknownHostException;  </div><div class="line">import java.util.Date;  </div><div class="line">import java.util.HashMap;  </div><div class="line">import java.util.Map;  </div><div class="line">  </div><div class="line">import org.elasticsearch.action.index.IndexResponse;  </div><div class="line">import org.elasticsearch.client.transport.TransportClient;  </div><div class="line">import org.elasticsearch.common.settings.Settings;  </div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;  </div><div class="line">import org.elasticsearch.common.xcontent.XContentBuilder;  </div><div class="line">import org.elasticsearch.common.xcontent.XContentFactory;  </div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;  </div><div class="line">import org.junit.Before;  </div><div class="line">import org.junit.Test;  </div><div class="line">  </div><div class="line">import com.fasterxml.jackson.core.JsonProcessingException;  </div><div class="line">import com.fasterxml.jackson.databind.ObjectMapper;  </div><div class="line">  </div><div class="line">public class CreateIndex &#123;  </div><div class="line">  </div><div class="line">    private TransportClient client;  </div><div class="line">      </div><div class="line">    @Before  </div><div class="line">    public void getClient() throws Exception&#123;  </div><div class="line">        //设置集群名称  </div><div class="line">        Settings settings = Settings.builder().put(&quot;cluster.name&quot;, &quot;my-application&quot;).build();// 集群名  </div><div class="line">        //创建client  </div><div class="line">        client  = new PreBuiltTransportClient(settings)  </div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;127.0.0.1&quot;), 9300));  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 手动生成JSON  </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateJSON()&#123;  </div><div class="line">          </div><div class="line">        String json = &quot;&#123;&quot; +  </div><div class="line">                &quot;\&quot;user\&quot;:\&quot;fendo\&quot;,&quot; +  </div><div class="line">                &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +  </div><div class="line">                &quot;\&quot;message\&quot;:\&quot;Hell word\&quot;&quot; +  </div><div class="line">            &quot;&#125;&quot;;  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">                .setSource(json)  </div><div class="line">                .get();  </div><div class="line">        System.out.println(response.getResult());  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 使用集合  </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateList()&#123;  </div><div class="line">          </div><div class="line">        Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();  </div><div class="line">        json.put(&quot;user&quot;,&quot;kimchy&quot;);  </div><div class="line">        json.put(&quot;postDate&quot;,&quot;2013-01-30&quot;);  </div><div class="line">        json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">                .setSource(json)  </div><div class="line">                .get();  </div><div class="line">        System.out.println(response.getResult());  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 使用JACKSON序列化  </div><div class="line">     * @throws Exception  </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateJACKSON() throws Exception&#123;  </div><div class="line">          </div><div class="line">        CsdnBlog csdn=new CsdnBlog();  </div><div class="line">        csdn.setAuthor(&quot;fendo&quot;);  </div><div class="line">        csdn.setContent(&quot;这是JAVA书籍&quot;);  </div><div class="line">        csdn.setTag(&quot;C&quot;);  </div><div class="line">        csdn.setView(&quot;100&quot;);  </div><div class="line">        csdn.setTitile(&quot;编程&quot;);  </div><div class="line">        csdn.setDate(new Date().toString());  </div><div class="line">          </div><div class="line">        // instance a json mapper  </div><div class="line">        ObjectMapper mapper = new ObjectMapper(); // create once, reuse  </div><div class="line">  </div><div class="line">        // generate json  </div><div class="line">        byte[] json = mapper.writeValueAsBytes(csdn);  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">                .setSource(json)  </div><div class="line">                .get();  </div><div class="line">        System.out.println(response.getResult());  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 使用ElasticSearch 帮助类  </div><div class="line">     * @throws IOException   </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateXContentBuilder() throws IOException&#123;  </div><div class="line">          </div><div class="line">        XContentBuilder builder = XContentFactory.jsonBuilder()  </div><div class="line">                .startObject()  </div><div class="line">                    .field(&quot;user&quot;, &quot;ccse&quot;)  </div><div class="line">                    .field(&quot;postDate&quot;, new Date())  </div><div class="line">                    .field(&quot;message&quot;, &quot;this is Elasticsearch&quot;)  </div><div class="line">                .endObject();  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodata&quot;).setSource(builder).get();  </div><div class="line">        System.out.println(&quot;创建成功!&quot;);  </div><div class="line">          </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>你还可以通过startArray(string)和endArray()方法添加数组。.field()方法可以接受多种对象类型。你可以给它传递数字、日期、甚至其他XContentBuilder对象。</p></blockquote><h3 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h3><p>根据id查看文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).get();</div></pre></td></tr></table></figure><p>更多请查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-get.html" target="_blank" rel="external">rest get API</a> 文档</p><h4 id="配置线程"><a href="#配置线程" class="headerlink" title="配置线程"></a>配置线程</h4><p><code>operationThreaded</code> 设置为 <code>true</code> 是在不同的线程里执行此次操作</p><p>下面的例子是<code>operationThreaded</code> 设置为 <code>false</code> ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setOperationThreaded(false)</div><div class="line">        .get();</div></pre></td></tr></table></figure></p><h3 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h3><p>根据ID删除：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).get();</div></pre></td></tr></table></figure><p>更多请查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-delete.html" target="_blank" rel="external">delete API</a> 文档</p><h4 id="配置线程-1"><a href="#配置线程-1" class="headerlink" title="配置线程"></a>配置线程</h4><p><code>operationThreaded</code> 设置为 <code>true</code> 是在不同的线程里执行此次操作</p><p>下面的例子是<code>operationThreaded</code> 设置为 <code>false</code> ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setOperationThreaded(false)</div><div class="line">        .get();</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setOperationThreaded(false)</div><div class="line">        .get();</div></pre></td></tr></table></figure><h3 id="Delete-By-Query-API"><a href="#Delete-By-Query-API" class="headerlink" title="Delete By Query API"></a>Delete By Query API</h3><p>通过查询条件删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkByScrollResponse response =</div><div class="line">    DeleteByQueryAction.INSTANCE.newRequestBuilder(client)</div><div class="line">        .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;)) //查询条件</div><div class="line">        .source(&quot;persons&quot;) //index(索引名)</div><div class="line">        .get();  //执行</div><div class="line"></div><div class="line">long deleted = response.getDeleted(); //删除文档的数量</div></pre></td></tr></table></figure><p>如果需要执行的时间比较长，可以使用异步的方式处理,结果在回调里面获取</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DeleteByQueryAction.INSTANCE.newRequestBuilder(client)</div><div class="line">    .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;))      //查询            </div><div class="line">    .source(&quot;persons&quot;)                //index(索引名)                                    </div><div class="line">    .execute(new ActionListener&lt;BulkByScrollResponse&gt;() &#123;     //回调监听     </div><div class="line">        @Override</div><div class="line">        public void onResponse(BulkByScrollResponse response) &#123;</div><div class="line">            long deleted = response.getDeleted();   //删除文档的数量                 </div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Exception e) &#123;</div><div class="line">            // Handle the exception</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><h3 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h3><p>有两种方式更新索引：</p><ul><li>创建 <code>UpdateRequest</code>,通过client发送；</li><li>使用 <code>prepareUpdate()</code> 方法；</li></ul><h4 id="使用UpdateRequest"><a href="#使用UpdateRequest" class="headerlink" title="使用UpdateRequest"></a>使用UpdateRequest</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UpdateRequest updateRequest = new UpdateRequest();</div><div class="line">updateRequest.index(&quot;index&quot;);</div><div class="line">updateRequest.type(&quot;type&quot;);</div><div class="line">updateRequest.id(&quot;1&quot;);</div><div class="line">updateRequest.doc(jsonBuilder()</div><div class="line">        .startObject()</div><div class="line">            .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">        .endObject());</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><h4 id="使用-prepareUpdate-方法"><a href="#使用-prepareUpdate-方法" class="headerlink" title="使用 prepareUpdate() 方法"></a>使用 <code>prepareUpdate()</code> 方法</h4><blockquote><p>这里官方的示例有问题，new Script（）参数错误，所以一下代码是我自己写的（2017/11/10）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;)</div><div class="line">        .setScript(new Script(&quot;ctx._source.gender = \&quot;male\&quot;&quot;  ,ScriptService.ScriptType.INLINE, null, null))//脚本可以是本地文件存储的，如果使用文件存储的脚本，需要设置 ScriptService.ScriptType.FILE </div><div class="line">        .get();</div><div class="line"></div><div class="line">client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;)</div><div class="line">        .setDoc(jsonBuilder()   //合并到现有文档</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject())</div><div class="line">        .get();</div></pre></td></tr></table></figure><h4 id="Update-by-script"><a href="#Update-by-script" class="headerlink" title="Update by script"></a>Update by script</h4><p>使用脚本更新文档 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UpdateRequest updateRequest = new UpdateRequest(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;)</div><div class="line">        .script(new Script(&quot;ctx._source.gender = \&quot;male\&quot;&quot;));</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><h4 id="Update-by-merging-documents"><a href="#Update-by-merging-documents" class="headerlink" title="Update by merging documents"></a>Update by merging documents</h4><p>合并文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;)</div><div class="line">        .doc(jsonBuilder()</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject());</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><h4 id="Upsert"><a href="#Upsert" class="headerlink" title="Upsert"></a>Upsert</h4><p>更新插入,如果存在文档就更新，如果不存在就插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IndexRequest indexRequest = new IndexRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;)</div><div class="line">        .source(jsonBuilder()</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;name&quot;, &quot;Joe Smith&quot;)</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject());</div><div class="line">UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;)</div><div class="line">        .doc(jsonBuilder()</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject())</div><div class="line">        .upsert(indexRequest); //如果不存在此文档 ，就增加 `indexRequest`</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><p>如果 <code>index/type/1</code> 存在，类似下面的文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;  : &quot;Joe Dalton&quot;,</div><div class="line">    &quot;gender&quot;: &quot;male&quot;        </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果不存在，会插入新的文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot; : &quot;Joe Smith&quot;,</div><div class="line">    &quot;gender&quot;: &quot;male&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Multi-Get-API"><a href="#Multi-Get-API" class="headerlink" title="Multi Get API"></a>Multi Get API</h3><p>一次获取多个文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MultiGetResponse multiGetItemResponses = client.prepareMultiGet()</div><div class="line">    .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) //一个id的方式</div><div class="line">    .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) //多个id的方式</div><div class="line">    .add(&quot;another&quot;, &quot;type&quot;, &quot;foo&quot;)  //可以从另外一个索引获取</div><div class="line">    .get();</div><div class="line"></div><div class="line">for (MultiGetItemResponse itemResponse : multiGetItemResponses) &#123; //迭代返回值</div><div class="line">    GetResponse response = itemResponse.getResponse();</div><div class="line">    if (response.isExists()) &#123;      //判断是否存在                </div><div class="line">        String json = response.getSourceAsString(); //_source 字段</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更多请浏览REST <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-multi-get.html" target="_blank" rel="external">multi get</a> 文档</p><h3 id="Bulk-API"><a href="#Bulk-API" class="headerlink" title="Bulk API"></a>Bulk API</h3><p>Bulk API，批量插入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import static org.elasticsearch.common.xcontent.XContentFactory.*;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkRequestBuilder bulkRequest = client.prepareBulk();</div><div class="line"></div><div class="line">// either use client#prepare, or use Requests# to directly build index/delete requests</div><div class="line">bulkRequest.add(client.prepareIndex(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setSource(jsonBuilder()</div><div class="line">                    .startObject()</div><div class="line">                        .field(&quot;user&quot;, &quot;kimchy&quot;)</div><div class="line">                        .field(&quot;postDate&quot;, new Date())</div><div class="line">                        .field(&quot;message&quot;, &quot;trying out Elasticsearch&quot;)</div><div class="line">                    .endObject()</div><div class="line">                  )</div><div class="line">        );</div><div class="line"></div><div class="line">bulkRequest.add(client.prepareIndex(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;)</div><div class="line">        .setSource(jsonBuilder()</div><div class="line">                    .startObject()</div><div class="line">                        .field(&quot;user&quot;, &quot;kimchy&quot;)</div><div class="line">                        .field(&quot;postDate&quot;, new Date())</div><div class="line">                        .field(&quot;message&quot;, &quot;another post&quot;)</div><div class="line">                    .endObject()</div><div class="line">                  )</div><div class="line">        );</div><div class="line"></div><div class="line">BulkResponse bulkResponse = bulkRequest.get();</div><div class="line">if (bulkResponse.hasFailures()) &#123;</div><div class="line">    // process failures by iterating through each bulk response item</div><div class="line">    //处理失败</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="使用-Bulk-Processor"><a href="#使用-Bulk-Processor" class="headerlink" title="使用 Bulk Processor"></a>使用 Bulk Processor</h3><p>BulkProcessor 提供了一个简单的接口，在给定的大小数量上定时批量自动请求</p><h4 id="创建BulkProcessor实例"><a href="#创建BulkProcessor实例" class="headerlink" title="创建BulkProcessor实例"></a>创建<code>BulkProcessor</code>实例</h4><p>首先创建<code>BulkProcessor</code>实例</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.elasticsearch.action.bulk.BackoffPolicy;</div><div class="line">import org.elasticsearch.action.bulk.BulkProcessor;</div><div class="line">import org.elasticsearch.common.unit.ByteSizeUnit;</div><div class="line">import org.elasticsearch.common.unit.ByteSizeValue;</div><div class="line">import org.elasticsearch.common.unit.TimeValue;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkProcessor bulkProcessor = BulkProcessor.builder(</div><div class="line">        client,  //增加elasticsearch客户端</div><div class="line">        new BulkProcessor.Listener() &#123;</div><div class="line">            @Override</div><div class="line">            public void beforeBulk(long executionId,</div><div class="line">                                   BulkRequest request) &#123; ... &#125; //调用bulk之前执行 ，例如你可以通过request.numberOfActions()方法知道numberOfActions</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void afterBulk(long executionId,</div><div class="line">                                  BulkRequest request,</div><div class="line">                                  BulkResponse response) &#123; ... &#125; //调用bulk之后执行 ，例如你可以通过request.hasFailures()方法知道是否执行失败</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void afterBulk(long executionId,</div><div class="line">                                  BulkRequest request,</div><div class="line">                                  Throwable failure) &#123; ... &#125; //调用失败抛 Throwable</div><div class="line">        &#125;)</div><div class="line">        .setBulkActions(10000) //每次10000请求</div><div class="line">        .setBulkSize(new ByteSizeValue(5, ByteSizeUnit.MB)) //拆成5mb一块</div><div class="line">        .setFlushInterval(TimeValue.timeValueSeconds(5)) //无论请求数量多少，每5秒钟请求一次。</div><div class="line">        .setConcurrentRequests(1) //设置并发请求的数量。值为0意味着只允许执行一个请求。值为1意味着允许1并发请求。</div><div class="line">        .setBackoffPolicy(</div><div class="line">            BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(100), 3))//设置自定义重复请求机制，最开始等待100毫秒，之后成倍更加，重试3次，当一次或多次重复请求失败后因为计算资源不够抛出 EsRejectedExecutionException 异常，可以通过BackoffPolicy.noBackoff()方法关闭重试机制</div><div class="line">        .build();</div></pre></td></tr></table></figure><h4 id="BulkProcessor-默认设置"><a href="#BulkProcessor-默认设置" class="headerlink" title="BulkProcessor 默认设置"></a>BulkProcessor 默认设置</h4><ul><li>bulkActions  1000 </li><li>bulkSize 5mb</li><li>不设置flushInterval</li><li>concurrentRequests 为 1 ，异步执行</li><li>backoffPolicy 重试 8次，等待50毫秒</li></ul><h4 id="增加requests"><a href="#增加requests" class="headerlink" title="增加requests"></a>增加requests</h4><p>然后增加<code>requests</code>到<code>BulkProcessor</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bulkProcessor.add(new IndexRequest(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).source(/* your doc here */));</div><div class="line">bulkProcessor.add(new DeleteRequest(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;));</div></pre></td></tr></table></figure></p><h4 id="关闭-Bulk-Processor"><a href="#关闭-Bulk-Processor" class="headerlink" title="关闭 Bulk Processor"></a>关闭 Bulk Processor</h4><p>当所有文档都处理完成，使用<code>awaitClose</code> 或 <code>close</code> 方法关闭<code>BulkProcessor</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bulkProcessor.awaitClose(10, TimeUnit.MINUTES);</div></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bulkProcessor.close();</div></pre></td></tr></table></figure><h4 id="在测试中使用Bulk-Processor"><a href="#在测试中使用Bulk-Processor" class="headerlink" title="在测试中使用Bulk Processor"></a>在测试中使用Bulk Processor</h4><p>如果你在测试种使用<code>Bulk Processor</code>可以执行同步方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkProcessor bulkProcessor = BulkProcessor.builder(client, new BulkProcessor.Listener() &#123; /* Listener methods */ &#125;)</div><div class="line">        .setBulkActions(10000)</div><div class="line">        .setConcurrentRequests(0)</div><div class="line">        .build();</div><div class="line"></div><div class="line">// Add your requests</div><div class="line">bulkProcessor.add(/* Your requests */);</div><div class="line"></div><div class="line">// Flush any remaining requests</div><div class="line">bulkProcessor.flush();</div><div class="line"></div><div class="line">// Or close the bulkProcessor if you don&apos;t need it anymore</div><div class="line">bulkProcessor.close();</div><div class="line"></div><div class="line">// Refresh your indices</div><div class="line">client.admin().indices().prepareRefresh().get();</div><div class="line"></div><div class="line">// Now you can start searching!</div><div class="line">client.prepareSearch().get();</div></pre></td></tr></table></figure></p><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><p>更多请浏览 <a href="https://github.com/quanke/spring-boot-starter-es" target="_blank" rel="external">spring-boot-starter-es</a> 开源项目</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节介绍以下 CRUD API：&lt;/p&gt;
&lt;p&gt; 单文档  APIs&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;document-apis/index-api.md&quot;&gt;Index API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;document-apis/get-ap
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API - 客户端连接(TransportClient，PreBuiltXPackTransportClient)（一）</title>
    <link href="http://quanke.name/posts/39952/"/>
    <id>http://quanke.name/posts/39952/</id>
    <published>2017-11-13T11:01:00.000Z</published>
    <updated>2018-02-02T15:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-Java-API-客户端连接"><a href="#Elasticsearch-Java-API-客户端连接" class="headerlink" title="Elasticsearch Java API 客户端连接"></a>Elasticsearch Java API 客户端连接</h2><p>一个是<code>TransportClient</code>，一个是<code>NodeClient</code>，还有一个<code>XPackTransportClient</code></p><ul><li>TransportClient：</li></ul><p>作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</p><ul><li>NodeClient</li></ul><p>作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的。</p><ul><li>XPackTransportClient：</li></ul><p>服务安装了 <code>x-pack</code> 插件</p><blockquote><p>重要：客户端版本应该和服务端版本保持一致</p><p>TransportClient旨在被Java高级REST客户端取代，该客户端执行HTTP请求而不是序列化的Java请求。 在即将到来的Elasticsearch版本中将不赞成使用TransportClient，建议使用Java高级REST客户端。</p><p>上面的警告比较尴尬，但是在 5xx版本中使用还是没有问题的，可能使用rest 客户端兼容性更好做一些。</p></blockquote><p><a href="https://www.gitbook.com/book/quanke/elasticsearch-java-rest" target="_blank" rel="external">Elasticsearch Java Rest API 手册</a></p><h3 id="Maven-Repository"><a href="#Maven-Repository" class="headerlink" title="Maven Repository"></a>Maven Repository</h3><p>Elasticsearch Java API包已经上传到 <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elasticsearch%22" target="_blank" rel="external">Maven Central</a></p><p>在<code>pom.xml</code>文件中增加：</p><blockquote><p>transport 版本号最好就是与Elasticsearch版本号一致。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;transport&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h3 id="Transport-Client"><a href="#Transport-Client" class="headerlink" title="Transport Client"></a>Transport Client</h3><h4 id="不设置集群名称"><a href="#不设置集群名称" class="headerlink" title="不设置集群名称"></a>不设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// on startup</div><div class="line"></div><div class="line">//此步骤添加IP，至少一个，如果设置了&quot;client.transport.sniff&quot;= true 一个就够了，因为添加了自动嗅探配置</div><div class="line">TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300))</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));</div><div class="line"></div><div class="line">// on shutdown  关闭client</div><div class="line"></div><div class="line">client.close();</div></pre></td></tr></table></figure><h4 id="设置集群名称"><a href="#设置集群名称" class="headerlink" title="设置集群名称"></a>设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build();  //设置ES实例的名称</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);  //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">//Add transport addresses and do something with the client...</div></pre></td></tr></table></figure><h4 id="增加自动嗅探配置"><a href="#增加自动嗅探配置" class="headerlink" title="增加自动嗅探配置"></a>增加自动嗅探配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;client.transport.sniff&quot;, true).build();</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);</div></pre></td></tr></table></figure><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">client.transport.ignore_cluster_name  //设置 true ，忽略连接节点集群名验证</div><div class="line">client.transport.ping_timeout       //ping一个节点的响应时间 默认5秒</div><div class="line">client.transport.nodes_sampler_interval //sample/ping 节点的时间间隔，默认是5s</div></pre></td></tr></table></figure><blockquote><p>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为：<br>TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。<br>NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</p></blockquote><p>如果用ES的节点，仁者见仁智者见智。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.es.study;</div><div class="line"></div><div class="line">import name.quanke.es.study.util.Utils;</div><div class="line">import org.elasticsearch.action.search.SearchResponse;</div><div class="line">import org.elasticsearch.client.transport.TransportClient;</div><div class="line">import org.elasticsearch.common.settings.Settings;</div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;</div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;</div><div class="line">import org.junit.After;</div><div class="line">import org.junit.Before;</div><div class="line"></div><div class="line">import java.net.InetAddress;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化</div><div class="line"> * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line"></div><div class="line">        Settings esSettings = Settings.builder()</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称</div><div class="line">                .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">                .build();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考&#123;@link ElasticsearchXPackClient&#125;</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        client = new PreBuiltTransportClient(esSettings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchClient 连接成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchClient.java）" target="_blank" rel="external">ElasticsearchClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><h3 id="XPackTransportClient"><a href="#XPackTransportClient" class="headerlink" title="XPackTransportClient"></a>XPackTransportClient</h3><p>如果 <code>ElasticSearch</code> 服务安装了 <code>x-pack</code> 插件，需要<code>PreBuiltXPackTransportClient</code>实例才能访问</p><p>使用Maven管理项目，把下面代码增加到<code>pom.xml</code>;</p><blockquote><p>一定要修改默认仓库地址为<a href="https://artifacts.elastic.co/maven" target="_blank" rel="external">https://artifacts.elastic.co/maven</a> ，因为这个库没有上传到Maven中央仓库,如果有自己的 maven ，请配置代理</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;project ...&gt;</div><div class="line"></div><div class="line">   &lt;repositories&gt;</div><div class="line">      &lt;!-- add the elasticsearch repo --&gt;</div><div class="line">      &lt;repository&gt;</div><div class="line">         &lt;id&gt;elasticsearch-releases&lt;/id&gt;</div><div class="line">         &lt;url&gt;https://artifacts.elastic.co/maven&lt;/url&gt;</div><div class="line">         &lt;releases&gt;</div><div class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">         &lt;/releases&gt;</div><div class="line">         &lt;snapshots&gt;</div><div class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">         &lt;/snapshots&gt;</div><div class="line">      &lt;/repository&gt;</div><div class="line">      ...</div><div class="line">   &lt;/repositories&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line">   &lt;dependencies&gt;</div><div class="line">      &lt;!-- add the x-pack jar as a dependency --&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;x-pack-transport&lt;/artifactId&gt;</div><div class="line">         &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">      ...</div><div class="line">   &lt;/dependencies&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line"> &lt;/project&gt;</div></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch XPack Client</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchXPackClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line">    </div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line">        /**</div><div class="line">         * 如果es集群安装了x-pack插件则以此种方式连接集群</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        Settings settings = Settings.builder()</div><div class="line">                .put(&quot;xpack.security.user&quot;, &quot;elastic:utan100&quot;)</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;)</div><div class="line">                .build();</div><div class="line">        client = new PreBuiltXPackTransportClient(settings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line">//        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</div><div class="line">//        credentialsProvider.setCredentials(AuthScope.ANY,</div><div class="line">//                new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;utan100&quot;));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchXPackClient 启动成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testClientConnection() throws Exception &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;--------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchXPackClient.java）" target="_blank" rel="external"> ElasticsearchXPackClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><p>更多请浏览 <a href="https://github.com/quanke/spring-boot-starter-es" target="_blank" rel="external">spring-boot-starter-es</a> 开源项目</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch-Java-API-客户端连接&quot;&gt;&lt;a href=&quot;#Elasticsearch-Java-API-客户端连接&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch Java API 客户端连接&quot;&gt;&lt;/a&gt;El
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="API" scheme="http://quanke.name/tags/API/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API - 客户端连接(TransportClient，PreBuiltXPackTransportClient)（一）</title>
    <link href="http://quanke.name/posts/39952/"/>
    <id>http://quanke.name/posts/39952/</id>
    <published>2017-11-13T11:01:00.000Z</published>
    <updated>2018-02-02T15:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-Java-API-客户端连接"><a href="#Elasticsearch-Java-API-客户端连接" class="headerlink" title="Elasticsearch Java API 客户端连接"></a>Elasticsearch Java API 客户端连接</h2><p>一个是<code>TransportClient</code>，一个是<code>NodeClient</code>，还有一个<code>XPackTransportClient</code></p><ul><li>TransportClient：</li></ul><p>作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</p><ul><li>NodeClient</li></ul><p>作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的。</p><ul><li>XPackTransportClient：</li></ul><p>服务安装了 <code>x-pack</code> 插件</p><blockquote><p>重要：客户端版本应该和服务端版本保持一致</p><p>TransportClient旨在被Java高级REST客户端取代，该客户端执行HTTP请求而不是序列化的Java请求。 在即将到来的Elasticsearch版本中将不赞成使用TransportClient，建议使用Java高级REST客户端。</p><p>上面的警告比较尴尬，但是在 5xx版本中使用还是没有问题的，可能使用rest 客户端兼容性更好做一些。</p></blockquote><p><a href="https://www.gitbook.com/book/quanke/elasticsearch-java-rest" target="_blank" rel="external">Elasticsearch Java Rest API 手册</a></p><h3 id="Maven-Repository"><a href="#Maven-Repository" class="headerlink" title="Maven Repository"></a>Maven Repository</h3><p>Elasticsearch Java API包已经上传到 <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elasticsearch%22" target="_blank" rel="external">Maven Central</a></p><p>在<code>pom.xml</code>文件中增加：</p><blockquote><p>transport 版本号最好就是与Elasticsearch版本号一致。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;transport&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h3 id="Transport-Client"><a href="#Transport-Client" class="headerlink" title="Transport Client"></a>Transport Client</h3><h4 id="不设置集群名称"><a href="#不设置集群名称" class="headerlink" title="不设置集群名称"></a>不设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// on startup</div><div class="line"></div><div class="line">//此步骤添加IP，至少一个，如果设置了&quot;client.transport.sniff&quot;= true 一个就够了，因为添加了自动嗅探配置</div><div class="line">TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300))</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));</div><div class="line"></div><div class="line">// on shutdown  关闭client</div><div class="line"></div><div class="line">client.close();</div></pre></td></tr></table></figure><h4 id="设置集群名称"><a href="#设置集群名称" class="headerlink" title="设置集群名称"></a>设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build();  //设置ES实例的名称</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);  //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">//Add transport addresses and do something with the client...</div></pre></td></tr></table></figure><h4 id="增加自动嗅探配置"><a href="#增加自动嗅探配置" class="headerlink" title="增加自动嗅探配置"></a>增加自动嗅探配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;client.transport.sniff&quot;, true).build();</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);</div></pre></td></tr></table></figure><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">client.transport.ignore_cluster_name  //设置 true ，忽略连接节点集群名验证</div><div class="line">client.transport.ping_timeout       //ping一个节点的响应时间 默认5秒</div><div class="line">client.transport.nodes_sampler_interval //sample/ping 节点的时间间隔，默认是5s</div></pre></td></tr></table></figure><blockquote><p>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为：<br>TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。<br>NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</p></blockquote><p>如果用ES的节点，仁者见仁智者见智。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.es.study;</div><div class="line"></div><div class="line">import name.quanke.es.study.util.Utils;</div><div class="line">import org.elasticsearch.action.search.SearchResponse;</div><div class="line">import org.elasticsearch.client.transport.TransportClient;</div><div class="line">import org.elasticsearch.common.settings.Settings;</div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;</div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;</div><div class="line">import org.junit.After;</div><div class="line">import org.junit.Before;</div><div class="line"></div><div class="line">import java.net.InetAddress;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化</div><div class="line"> * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line"></div><div class="line">        Settings esSettings = Settings.builder()</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称</div><div class="line">                .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">                .build();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考&#123;@link ElasticsearchXPackClient&#125;</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        client = new PreBuiltTransportClient(esSettings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchClient 连接成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchClient.java）" target="_blank" rel="external">ElasticsearchClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><h3 id="XPackTransportClient"><a href="#XPackTransportClient" class="headerlink" title="XPackTransportClient"></a>XPackTransportClient</h3><p>如果 <code>ElasticSearch</code> 服务安装了 <code>x-pack</code> 插件，需要<code>PreBuiltXPackTransportClient</code>实例才能访问</p><p>使用Maven管理项目，把下面代码增加到<code>pom.xml</code>;</p><blockquote><p>一定要修改默认仓库地址为<a href="https://artifacts.elastic.co/maven" target="_blank" rel="external">https://artifacts.elastic.co/maven</a> ，因为这个库没有上传到Maven中央仓库,如果有自己的 maven ，请配置代理</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;project ...&gt;</div><div class="line"></div><div class="line">   &lt;repositories&gt;</div><div class="line">      &lt;!-- add the elasticsearch repo --&gt;</div><div class="line">      &lt;repository&gt;</div><div class="line">         &lt;id&gt;elasticsearch-releases&lt;/id&gt;</div><div class="line">         &lt;url&gt;https://artifacts.elastic.co/maven&lt;/url&gt;</div><div class="line">         &lt;releases&gt;</div><div class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">         &lt;/releases&gt;</div><div class="line">         &lt;snapshots&gt;</div><div class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">         &lt;/snapshots&gt;</div><div class="line">      &lt;/repository&gt;</div><div class="line">      ...</div><div class="line">   &lt;/repositories&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line">   &lt;dependencies&gt;</div><div class="line">      &lt;!-- add the x-pack jar as a dependency --&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;x-pack-transport&lt;/artifactId&gt;</div><div class="line">         &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">      ...</div><div class="line">   &lt;/dependencies&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line"> &lt;/project&gt;</div></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch XPack Client</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchXPackClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line">    </div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line">        /**</div><div class="line">         * 如果es集群安装了x-pack插件则以此种方式连接集群</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        Settings settings = Settings.builder()</div><div class="line">                .put(&quot;xpack.security.user&quot;, &quot;elastic:utan100&quot;)</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;)</div><div class="line">                .build();</div><div class="line">        client = new PreBuiltXPackTransportClient(settings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line">//        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</div><div class="line">//        credentialsProvider.setCredentials(AuthScope.ANY,</div><div class="line">//                new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;utan100&quot;));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchXPackClient 启动成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testClientConnection() throws Exception &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;--------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchXPackClient.java）" target="_blank" rel="external"> ElasticsearchXPackClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><p>更多请浏览 <a href="https://github.com/quanke/spring-boot-starter-es" target="_blank" rel="external">spring-boot-starter-es</a> 开源项目</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch-Java-API-客户端连接&quot;&gt;&lt;a href=&quot;#Elasticsearch-Java-API-客户端连接&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch Java API 客户端连接&quot;&gt;&lt;/a&gt;El
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="API" scheme="http://quanke.name/tags/API/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 5.6 Java API 中文手册 </title>
    <link href="http://quanke.name/posts/21227/"/>
    <id>http://quanke.name/posts/21227/</id>
    <published>2017-11-08T09:21:00.000Z</published>
    <updated>2018-02-02T15:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/432952-5448f57c503678f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Elasticsearch 5.6 Java API 中文手册 "></p><p>本手册由 <a href="http://quanke.name">全科</a> 翻译，并且整理成电子书，支持PDF,ePub,Mobi格式，方便大家下载阅读。</p><blockquote><p>不只是官方文档的翻译，还包含使用实例，包含我们使用踩过的坑</p></blockquote><p>阅读地址：<a href="https://es.quanke.name" target="_blank" rel="external">https://es.quanke.name</a></p><p>下载地址：<a href="https://www.gitbook.com/book/quanke/elasticsearch-java" target="_blank" rel="external">https://www.gitbook.com/book/quanke/elasticsearch-java</a></p><p>github地址：<a href="https://github.com/quanke/elasticsearch-java" target="_blank" rel="external">https://github.com/quanke/elasticsearch-java</a></p><p>编辑：<a href="http://quanke.name">http://quanke.name</a></p><p>编辑整理辛苦，还望大神们点一下star ，抚平我虚荣的心</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/432952-5448f57c503678f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="API" scheme="http://quanke.name/tags/API/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>使用PM2运行node.js服务</title>
    <link href="http://quanke.name/posts/19415/"/>
    <id>http://quanke.name/posts/19415/</id>
    <published>2017-11-06T08:20:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><hr><ul><li>GitHub 地址：  <a href="https://github.com/Unitech/pm2" target="_blank" rel="external">https://github.com/Unitech/pm2</a></li><li>官网： <a href="http://pm2.keymetrics.io/" target="_blank" rel="external">http://pm2.keymetrics.io/</a></li></ul><h2 id="为什么需要使用PM2"><a href="#为什么需要使用PM2" class="headerlink" title="为什么需要使用PM2"></a>为什么需要使用PM2</h2><p>因为node.js 是单进程，进程被杀死后整个服务就跪了，所以需要进程管理工具，但是pm2 远远不止这些。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PM2 是一个带有负载均衡功能的 Node 应用的进程管理器。</p><p>当你要把你的独立代码利用全部的服务器上的所有 CPU，并保证进程永远都活着，0 秒的重载， PM2 是完美的。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>内建负载均衡（使用Node cluster 集群模块）</li><li>后台运行</li><li>0秒停机重载(维护升级的时候不需要停机).</li><li>具有Ubuntu和CentOS 的启动脚本</li><li>停止不稳定的进程（避免无限循环）</li><li>控制台检测</li><li>提供 HTTP API</li><li>远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>首先确保有node.js 的环境</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install -g pm2</div></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start app.js --name my-api # 命名进程</div></pre></td></tr></table></figure><h3 id="其他运行方式："><a href="#其他运行方式：" class="headerlink" title="其他运行方式："></a>其他运行方式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start app.js -i max  # 根据有效CPU数目启动最大进程数目</div><div class="line">pm2 start app.js -i 3      # 启动3个进程</div><div class="line">pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster</div><div class="line">pm2 start app.js -x -- -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)</div><div class="line">pm2 start app.js --name serverone  # 启动一个进程并把它命名为 serverone</div><div class="line">pm2 stop serverone       # 停止 serverone 进程</div><div class="line">pm2 start app.json        # 启动进程, 在 app.json里设置选项</div><div class="line">pm2 start app.js -i max -- -a 23                   #在--之后给 app.js 传递参数</div><div class="line">pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件，你也可以执行用其他语言编写的app  ( fork 模式):</div><div class="line">pm2 start my-bash-script.sh    -x --interpreter bash</div><div class="line">pm2 start my-python-script.py -x --interpreter python</div></pre></td></tr></table></figure><h3 id="npm-运行"><a href="#npm-运行" class="headerlink" title="npm 运行"></a>npm 运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start npm -- start</div></pre></td></tr></table></figure><p>动一个进程并把它命名为 test<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start npm --name test -- start</div></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install pm2 -g     # 命令行安装 pm2 </div><div class="line">pm2 start app.js -i 4 #后台运行pm2，启动4个app.js </div><div class="line">                              # 也可以把&apos;max&apos; 参数传递给 start</div><div class="line">                              # 正确的进程数目依赖于Cpu的核心数目</div><div class="line">pm2 start app.js --name my-api # 命名进程</div><div class="line">pm2 list               # 显示所有进程状态</div><div class="line">pm2 monit              # 监视所有进程</div><div class="line">pm2 logs               #  显示所有进程日志</div><div class="line">pm2 stop all           # 停止所有进程</div><div class="line">pm2 restart all        # 重启所有进程</div><div class="line">pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</div><div class="line">pm2 stop 0             # 停止指定的进程</div><div class="line">pm2 restart 0          # 重启指定的进程</div><div class="line">pm2 startup            # 产生 init 脚本 保持进程活着</div><div class="line">pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</div><div class="line">pm2 delete 0           # 杀死指定的进程</div><div class="line">pm2 delete all         # 杀死全部进程</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.douban.com/note/314200231/" target="_blank" rel="external">https://www.douban.com/note/314200231/</a></li><li><a href="https://stackoverflow.com/questions/31579509/can-pm2-run-an-npm-start-script" target="_blank" rel="external">https://stackoverflow.com/questions/31579509/can-pm2-run-an-npm-start-script</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;GitHub 地址：  &lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="node.js" scheme="http://quanke.name/categories/node/"/>
    
    
      <category term="PM2" scheme="http://quanke.name/tags/PM2/"/>
    
      <category term="node.js 运行" scheme="http://quanke.name/tags/node-js-%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>swagger-edit写接口文档神器的部署和使用</title>
    <link href="http://quanke.name/posts/41016/"/>
    <id>http://quanke.name/posts/41016/</id>
    <published>2017-11-06T08:18:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>swagger 是一套开源的API设计工具，包括Swagger UI，Swagger Editor等。</p><p>其中Swagger Editor是个WEB小程序，它可以让你用YAML来定义你的接口规范，并实时验证和现实成接口文档。</p><p>我们主要使用Swagger Editor 编写接口文档，在线 <a href="https://editor.swagger.io" target="_blank" rel="external">Swagger Editor</a> 也是可以使用的，但是访问速度在国内有点慢，所以为了效率，自己在服务器搭建一套服务</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>直接git clone 最新代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone https://github.com/swagger-api/swagger-editor.git</div></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>首先确保有node.js 的环境</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cd swagger-edito</div><div class="line">npm install</div></pre></td></tr></table></figure><blockquote><p>安装 PM2 ,如果不会PM2，请查看 <a href="http://quanke.name/2017/11/06/%E4%BD%BF%E7%94%A8PM2%E8%BF%90%E8%A1%8Cnode-js%E6%9C%8D%E5%8A%A1/">《使用PM2运行node.js服务》</a> </p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用PM2运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start npm -- start</div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>访问：</p><p><a href="http://192.168.2.52:3001/" target="_blank" rel="external">http://192.168.2.52:3001/</a></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="http://blog.csdn.net/wangmeng951011/article/details/67640375" target="_blank" rel="external">http://blog.csdn.net/wangmeng951011/article/details/67640375</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="使用" scheme="http://quanke.name/categories/use/"/>
    
    
      <category term="接口文档" scheme="http://quanke.name/tags/api/"/>
    
      <category term="swagger-api" scheme="http://quanke.name/tags/swagger-api/"/>
    
      <category term="swagger-edit" scheme="http://quanke.name/tags/swagger-edit/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch5xx使用logstash同步mysql</title>
    <link href="http://quanke.name/posts/108/"/>
    <id>http://quanke.name/posts/108/</id>
    <published>2017-11-06T07:53:00.000Z</published>
    <updated>2018-02-02T15:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="下载logstash"><a href="#下载logstash" class="headerlink" title="下载logstash"></a>下载logstash</h4><p>下载地址：<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a></p><blockquote><p>当时我下载的是5.6.3版本</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure><p>解压：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tar -zxvf logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure></p><p>进入安装目录</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div></pre></td></tr></table></figure><p>等待几秒钟 出现  </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">The stdin plugin is now waiting for input:</div></pre></td></tr></table></figure><p>然后输入 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure><p>得到类似的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2017-10-30T02:49:59.005Z test-env hello world</div></pre></td></tr></table></figure></p><h4 id="安装logstash-input-jdbc插件"><a href="#安装logstash-input-jdbc插件" class="headerlink" title="安装logstash-input-jdbc插件"></a>安装logstash-input-jdbc插件</h4><p>1.安装 ruby 和 rubygems（注意：需要 ruby 的版本在 1.8.7 以上）</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yum install -y ruby rubygems</div></pre></td></tr></table></figure><p>检查 ruby 版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-linux]</div></pre></td></tr></table></figure><p>替换国内的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources --remove http://rubygems.org/</div><div class="line">gem sources -a http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>验证是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line"></div><div class="line">http://rubygems.org/</div><div class="line">http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>修改Gemfile的数据源地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim Gemfile</div></pre></td></tr></table></figure><p>修改 source 的值 为： <code>&quot;https://gems.ruby-china.org/&quot;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim  Gemfile.jruby-1.9.lock</div></pre></td></tr></table></figure><p>找到 remote 修改它的值为：<code>https://gems.ruby-china.org/</code></p><p>开始安装:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./bin/logstash-plugin install --no-verify  logstash-input-jdbc</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Installing logstash-input-jdbc</div><div class="line">Installation successful</div></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h4><p>最基本的配置文件定义，必须包含input 和 output。如果需要对数据进操作，则需要加上filter段</p><p>配置 java mysql 连接驱动 <code>mysql-connector-java-5.1.42-bin.jar</code> </p><p><a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz" target="_blank" rel="external">https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input &#123;</div><div class="line">  stdin &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  jdbc &#123;</div><div class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://dbs1:3306/db2_utan_cs&quot;</div><div class="line">    jdbc_user =&gt; &quot;root&quot;</div><div class="line">    jdbc_password =&gt; &quot;123456&quot;</div><div class="line">    jdbc_driver_library =&gt; &quot;/data/arrow/logstash/mysql-connector-java-5.1.42-bin.jar&quot;</div><div class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</div><div class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</div><div class="line">    jdbc_page_size =&gt; &quot;50000&quot;</div><div class="line">    statement =&gt; &quot;SELECT * FROM crawler_data WHERE id &gt; (SELECT MAX(t1.id) FROM db2_utan_cs.crawler_data AS t1)-70000 AND updatetime &gt; :sql_last_value&quot;</div><div class="line">    use_column_value =&gt; true</div><div class="line">    tracking_column =&gt; &quot;updatetime&quot;</div><div class="line">    schedule =&gt; &quot;* * * * *&quot;</div><div class="line">    type =&gt; &quot;baby_crawler&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">filter &#123;</div><div class="line">  mutate &#123;</div><div class="line">    remove_field =&gt; [ &quot;@timestamp&quot;, &quot;@version&quot;, &quot;id&quot; ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">output &#123;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; &quot;192.168.1.21:9201&quot;</div><div class="line">    index =&gt; &quot;baby_crawler_b&quot;</div><div class="line">    document_id =&gt; &quot;%&#123;uniquekey&#125;&quot;</div><div class="line">  &#125;</div><div class="line">  stdout &#123;</div><div class="line">    codec =&gt; json_lines</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"># 通过手动指定配置文件启动</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf</div><div class="line"> </div><div class="line"># 以daemon方式运行，则在指令后面加一个 &amp; 符号</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf &amp;</div><div class="line"> </div><div class="line"> </div><div class="line"># 如果是通过rpm包安装的logstash则可以使用自带的脚本启动</div><div class="line"> </div><div class="line">/etc/init.d/logstash start </div><div class="line"> </div><div class="line"># 通过这种方式启动，logstash会自动加载 /etc/logstash/conf.d/ 下的配置文件</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://tchuairen.blog.51cto.com/3848118/1840596/" target="_blank" rel="external">http://tchuairen.blog.51cto.com/3848118/1840596/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;下载logstash&quot;&gt;&lt;a href=&quot;#下载logstash&quot; class=&quot;headerlink&quot; title=&quot;下载log
      
    
    </summary>
    
      <category term="大数据" scheme="http://quanke.name/categories/bdata/"/>
    
    
      <category term="logstash" scheme="http://quanke.name/tags/logstash/"/>
    
      <category term="elasticsearch" scheme="http://quanke.name/tags/elasticsearch/"/>
    
      <category term="mysql" scheme="http://quanke.name/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch5xx使用logstash同步mysql</title>
    <link href="http://quanke.name/posts/108/"/>
    <id>http://quanke.name/posts/108/</id>
    <published>2017-11-06T07:53:00.000Z</published>
    <updated>2018-02-02T15:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="下载logstash"><a href="#下载logstash" class="headerlink" title="下载logstash"></a>下载logstash</h4><p>下载地址：<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a></p><blockquote><p>当时我下载的是5.6.3版本</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure><p>解压：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tar -zxvf logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure></p><p>进入安装目录</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div></pre></td></tr></table></figure><p>等待几秒钟 出现  </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">The stdin plugin is now waiting for input:</div></pre></td></tr></table></figure><p>然后输入 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure><p>得到类似的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2017-10-30T02:49:59.005Z test-env hello world</div></pre></td></tr></table></figure></p><h4 id="安装logstash-input-jdbc插件"><a href="#安装logstash-input-jdbc插件" class="headerlink" title="安装logstash-input-jdbc插件"></a>安装logstash-input-jdbc插件</h4><p>1.安装 ruby 和 rubygems（注意：需要 ruby 的版本在 1.8.7 以上）</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yum install -y ruby rubygems</div></pre></td></tr></table></figure><p>检查 ruby 版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-linux]</div></pre></td></tr></table></figure><p>替换国内的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources --remove http://rubygems.org/</div><div class="line">gem sources -a http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>验证是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line"></div><div class="line">http://rubygems.org/</div><div class="line">http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>修改Gemfile的数据源地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim Gemfile</div></pre></td></tr></table></figure><p>修改 source 的值 为： <code>&quot;https://gems.ruby-china.org/&quot;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim  Gemfile.jruby-1.9.lock</div></pre></td></tr></table></figure><p>找到 remote 修改它的值为：<code>https://gems.ruby-china.org/</code></p><p>开始安装:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./bin/logstash-plugin install --no-verify  logstash-input-jdbc</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Installing logstash-input-jdbc</div><div class="line">Installation successful</div></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h4><p>最基本的配置文件定义，必须包含input 和 output。如果需要对数据进操作，则需要加上filter段</p><p>配置 java mysql 连接驱动 <code>mysql-connector-java-5.1.42-bin.jar</code> </p><p><a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz" target="_blank" rel="external">https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input &#123;</div><div class="line">  stdin &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  jdbc &#123;</div><div class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://dbs1:3306/db2_utan_cs&quot;</div><div class="line">    jdbc_user =&gt; &quot;root&quot;</div><div class="line">    jdbc_password =&gt; &quot;123456&quot;</div><div class="line">    jdbc_driver_library =&gt; &quot;/data/arrow/logstash/mysql-connector-java-5.1.42-bin.jar&quot;</div><div class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</div><div class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</div><div class="line">    jdbc_page_size =&gt; &quot;50000&quot;</div><div class="line">    statement =&gt; &quot;SELECT * FROM crawler_data WHERE id &gt; (SELECT MAX(t1.id) FROM db2_utan_cs.crawler_data AS t1)-70000 AND updatetime &gt; :sql_last_value&quot;</div><div class="line">    use_column_value =&gt; true</div><div class="line">    tracking_column =&gt; &quot;updatetime&quot;</div><div class="line">    schedule =&gt; &quot;* * * * *&quot;</div><div class="line">    type =&gt; &quot;baby_crawler&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">filter &#123;</div><div class="line">  mutate &#123;</div><div class="line">    remove_field =&gt; [ &quot;@timestamp&quot;, &quot;@version&quot;, &quot;id&quot; ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">output &#123;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; &quot;192.168.1.21:9201&quot;</div><div class="line">    index =&gt; &quot;baby_crawler_b&quot;</div><div class="line">    document_id =&gt; &quot;%&#123;uniquekey&#125;&quot;</div><div class="line">  &#125;</div><div class="line">  stdout &#123;</div><div class="line">    codec =&gt; json_lines</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"># 通过手动指定配置文件启动</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf</div><div class="line"> </div><div class="line"># 以daemon方式运行，则在指令后面加一个 &amp; 符号</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf &amp;</div><div class="line"> </div><div class="line"> </div><div class="line"># 如果是通过rpm包安装的logstash则可以使用自带的脚本启动</div><div class="line"> </div><div class="line">/etc/init.d/logstash start </div><div class="line"> </div><div class="line"># 通过这种方式启动，logstash会自动加载 /etc/logstash/conf.d/ 下的配置文件</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://tchuairen.blog.51cto.com/3848118/1840596/" target="_blank" rel="external">http://tchuairen.blog.51cto.com/3848118/1840596/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;下载logstash&quot;&gt;&lt;a href=&quot;#下载logstash&quot; class=&quot;headerlink&quot; title=&quot;下载log
      
    
    </summary>
    
      <category term="大数据" scheme="http://quanke.name/categories/bdata/"/>
    
    
      <category term="logstash" scheme="http://quanke.name/tags/logstash/"/>
    
      <category term="elasticsearch" scheme="http://quanke.name/tags/elasticsearch/"/>
    
      <category term="mysql" scheme="http://quanke.name/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>已有Android工程 集成React Native 的那些事</title>
    <link href="http://quanke.name/posts/27127/"/>
    <id>http://quanke.name/posts/27127/</id>
    <published>2017-02-28T15:03:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>2017年2月27日，天气晴，我永远记得这天，我心潮澎湃，因为终于把<a href="http://utantop.com/" target="_blank" rel="external">优谈TOP</a> 集成了React Native，从去年开始，公司陆陆续续的集成和学习React Native，通过demo的形式，写了不少组件和API，也能和后端调通，也多次，多个人尝试把优谈TOP集成React Native，但是每次都是失败的，因为缺少经验，不能直接通过错误判断原因，只能通过Google查找各种资料，慢慢解决，下面记录了我们，<a href="http://utantop.com/" target="_blank" rel="external">优谈TOP</a> 原生 集成React Native 的那些事。也许也是你的那些事？</p><h3 id="常规思路："><a href="#常规思路：" class="headerlink" title="常规思路："></a>常规思路：</h3><p>通过百度搜索 <code>已有Android工程集成ReactNative</code> 出现一大堆教程，大部分教程都是通过在原来的基础上增加React Native的支持，比如这个：<a href="http://blog.csdn.net/jj120522/article/details/51982228" target="_blank" rel="external">《Android之原生项目集成React Native》</a> ，这也是官方推荐的集成方式，我也推荐这个，只是我这样，一直报错，有一个启动 MainaAtivity的错，一直过不去，所以我就换一种思路。。。</p><h3 id="在React-Native基础上增加原生"><a href="#在React-Native基础上增加原生" class="headerlink" title="在React Native基础上增加原生"></a>在React Native基础上增加原生</h3><p>开始通过<a href="http://facebook.github.io/react-native/docs/getting-started.html#content" target="_blank" rel="external">官方文档安装和初始化</a>React Native项目。</p><h4 id="创建和运行React-Native-项目"><a href="#创建和运行React-Native-项目" class="headerlink" title="创建和运行React Native 项目"></a>创建和运行React Native 项目</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native init UtanTop</div><div class="line"></div><div class="line">cd UtanTop</div><div class="line"></div><div class="line">react-native run-android</div></pre></td></tr></table></figure><blockquote><p>如果没有错,再继续。如果有错，说明你环境都没有安装好，哈哈。请参考<a href="http://reactnative.cn/docs/0.41/getting-started.html" target="_blank" rel="external">环境安装文档</a></p></blockquote><p>恭喜你，第一步搞定了。接下来，巨坑的地方要来了。</p><h4 id="把原生的-build-gradle-文件先集成进去"><a href="#把原生的-build-gradle-文件先集成进去" class="headerlink" title="把原生的 build.gradle 文件先集成进去"></a>把原生的 <code>build.gradle</code> 文件先集成进去</h4><p>这一步比较简单，就是把<code>gradle</code>相关文件复制替换就可以了，你想的好简单哈。。。</p><p><strong>我建议：</strong></p><p>首先把原项目的gradle相关文件复制到新建的React Native项目，<em>不要破坏原来的React Native项目的配置</em>。</p><blockquote><p>如果原生项目里有Module，先不要把Module导入，为了保险，把最简单的导入。</p></blockquote><h5 id="修改Root-目录下的build-gradle"><a href="#修改Root-目录下的build-gradle" class="headerlink" title="修改Root 目录下的build.gradle"></a>修改Root 目录下的<code>build.gradle</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenLocal()</div><div class="line">        jcenter()</div><div class="line">        maven &#123;</div><div class="line">            url &quot;http://192.168.1.205:8081/repository/utancenter/&quot;</div><div class="line">        &#125;</div><div class="line">        maven &#123;</div><div class="line">            // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm</div><div class="line">            url &quot;$rootDir/../node_modules/react-native/android&quot;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果有其他maven仓库直接这么写就可以了。</p><h5 id="配置app目录下的build-gradle"><a href="#配置app目录下的build-gradle" class="headerlink" title="配置app目录下的build.gradle"></a>配置app目录下的<code>build.gradle</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line"></div><div class="line"></div><div class="line">//        release &#123;</div><div class="line">//            // 不显示Log</div><div class="line">//            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;</div><div class="line">//</div><div class="line">//            minifyEnabled enableProguardInReleaseBuilds</div><div class="line">//            zipAlignEnabled true</div><div class="line">//            shrinkResources true</div><div class="line">//            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-project.txt&apos;</div><div class="line">//            signingConfig signingConfigs.release</div><div class="line">//</div><div class="line">//            applicationVariants.all &#123; variant -&gt;</div><div class="line">//                variant.outputs.each &#123; output -&gt;</div><div class="line">//                    def outputFile = output.outputFile</div><div class="line">//                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123;</div><div class="line">//</div><div class="line">//                        //if (&quot;woman&quot;.equals(WOMAN))&#123;</div><div class="line">//                        //  def fileName = &quot;WomanTop_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;</div><div class="line">//                        //output.outputFile = new File(outputFile.parent+File.separator+&quot;v&quot;+defaultConfig.versionName, fileName)</div><div class="line">//                        //&#125; else &#123;</div><div class="line">//                        def fileName = &quot;UtanTop_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;</div><div class="line">//                        output.outputFile = new File(outputFile.parent + File.separator + &quot;v&quot; + defaultConfig.versionName, fileName)</div><div class="line">//                        //&#125;</div><div class="line">//</div><div class="line">//</div><div class="line">//                    &#125;</div><div class="line">//                &#125;</div><div class="line">//            &#125;</div><div class="line">//        &#125;</div><div class="line"></div><div class="line">        release &#123;</div><div class="line">            minifyEnabled enableProguardInReleaseBuilds</div><div class="line">            proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>贴这个的意思就是先把打渠道包的去掉，使用React Native生成的配置，之后打渠道包在说，记得把下面几段也要先注释掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//    // 多渠道打包</div><div class="line">//    productFlavors &#123;</div><div class="line"></div><div class="line">//        T1 &#123;&#125;</div><div class="line">//        T2 &#123;&#125;</div><div class="line">//        T3 &#123;&#125;</div><div class="line">//</div><div class="line">//    &#125;</div><div class="line">//</div><div class="line">//    productFlavors.all &#123; flavor -&gt;</div><div class="line">//        flavor.manifestPlaceholders = [CHANNEL_VALUE: name]</div><div class="line">//    &#125;</div></pre></td></tr></table></figure><p>如果集成友盟的多渠道包，还需要在<code>AndroidManifest.xml</code>中注释掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">           android:name=&quot;UMENG_APPKEY&quot;</div><div class="line">           android:value=&quot;$&#123;UMENG_APPKEY&#125;&quot; /&gt;</div></pre></td></tr></table></figure><p>在这个时候我们还没集成源码，再执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure><blockquote><p>如果编译通过，恭喜你，如果没有过那是正常的，因为还有一个坑。</p></blockquote><p>我的报错信息是</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">* What went wrong:</div><div class="line">Execution failed for task &apos;:app:packageAllDebugClassesForMultiDex&apos;.</div><div class="line">&gt; java.util.zip.ZipException: duplicate entry: bolts/AggregateException.class</div></pre></td></tr></table></figure><p>是因为导入了重复的条目。</p><blockquote><p>可能是在某些某些gradle版本才有吧。。。</p></blockquote><p>我的解决方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">compile(&apos;com.facebook.fresco:fresco:0.10.0&apos;) &#123;</div><div class="line">    exclude group: &apos;com.parse.bolts&apos;,</div><div class="line">            module: &apos;bolts-android&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compile (&apos;com.facebook.fresco:animated-gif:0.10.0&apos;)&#123;</div><div class="line">    exclude group: &apos;com.parse.bolts&apos;,</div><div class="line">            module: &apos;bolts-android&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时候再执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure><p>现在问题应该不大了，按道理可以运行起来了，反正我的运行起来了，但是还没有加入源码。。。</p><h5 id="现在就把java-res-libs-assets-目录下的文件和-AndroidManifest-xml-复制到React-Native项目中。"><a href="#现在就把java-res-libs-assets-目录下的文件和-AndroidManifest-xml-复制到React-Native项目中。" class="headerlink" title="现在就把java res libs assets 目录下的文件和 AndroidManifest.xml 复制到React Native项目中。"></a>现在就把<code>java</code> <code>res</code> <code>libs</code> <code>assets</code> 目录下的文件和 <code>AndroidManifest.xml</code> 复制到React Native项目中。</h5><p>把<code>MainApplication</code> 集成你原生项目的<code>Application</code> </p><blockquote><p>一般项目都会自定一个<code>Application</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class MainApplication extends UtanToutiaoApp implements ReactApplication &#123;</div><div class="line"></div><div class="line">  private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;</div><div class="line">    @Override</div><div class="line">    public boolean getUseDeveloperSupport() &#123;</div><div class="line">      return BuildConfig.DEBUG;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected List&lt;ReactPackage&gt; getPackages() &#123;</div><div class="line">      return Arrays.&lt;ReactPackage&gt;asList(</div><div class="line">          new MainReactPackage()</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public ReactNativeHost getReactNativeHost() &#123;</div><div class="line">    return mReactNativeHost;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onCreate() &#123;</div><div class="line">    super.onCreate();</div><div class="line">    SoLoader.init(this, /* native exopackage */ false);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>注意：不要把<code>MainActivity</code> <code>MainApplication</code> ,文件覆盖了。</p></blockquote><p>再执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure><p>应该可以成功了，如果默认启动的是<code>MainActivity</code>，那展示的就是React Native 界面，如果默认不是<code>MainActivity</code>，那就通过下面的方式启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">Intent i = new Intent(context, MainReactActivity.class);</div><div class="line">    </div><div class="line">context.startActivity(i);</div></pre></td></tr></table></figure><p>到这里我反正就ok了，不知道你ok了没？</p><p>如果不OK ，请留言，一起探讨。。</p><p>还有我在学习和使用React Native 之后也会贴出来供大伙参考。。请关注 quanke</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2017年2月27日，天气晴，我永远记得这天，我心潮澎湃，因为终于把&lt;a hr
      
    
    </summary>
    
      <category term="React Native" scheme="http://quanke.name/categories/rn/"/>
    
    
      <category term="React Native" scheme="http://quanke.name/tags/rn/"/>
    
      <category term="React" scheme="http://quanke.name/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包</title>
    <link href="http://quanke.name/posts/55306/"/>
    <id>http://quanke.name/posts/55306/</id>
    <published>2017-02-22T16:07:42.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><h1 id="Android-Gradle-相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包"><a href="#Android-Gradle-相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包" class="headerlink" title="Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包"></a>Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包</h1><p>简介：<br>公司的新需求：同一份代码打出另一个包名的apk，即包名不同、名称不同的两个apk。因为市场是识别包名的，所有可以相同的代码可以发布多个APP，以便于测试什么样的名字被用户接受（本人不太认同这种观点，这里只谈技术），可以在同一个手机同时安装测试包和发布包（大部分测试的接口地址与发布的接口地址是不一样的，还有一些公司还有开发的接口），方便测试</p><p>我经过多方渠道发现大致有一下三种方法：</p><ul><li><strong>通过ant打多包名应用</strong></li><li><strong>建立多个与“main”同级的文件夹，修改清单文件及build.gradle以达到打多包名效果</strong></li><li><strong>通过修改build.gradle文件的applicationId达到打多包名的效果，原理与第二种方法但比较简单</strong></li></ul><p>因为是新手，对ant并不太了解，原理也不太清楚，为了赶时间所以直接选择了第二种与第三种方法，经过测试发现第三种方法要更加简单的多，所以最后直接使用了第三种方法，以下为详解。</p><hr><p>因为要修改的是build.gradle文件而该文件一经修改就要重新编译，用过史丢丢的童鞋应该都清楚等待编译完成是是件多么蛋疼的事情所以建议大家一次性修改完成以便节约开发时间。</p><p>上面已经说过该方法主要是通过修改build.gradle文件的applicationId达到打多包名的效果的，下面便粘出本人代码供大家参考。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">      app_one &#123;</div><div class="line">          applicationId &quot;com.example.app1&quot;</div><div class="line">          manifestPlaceholders = [</div><div class="line">                  app_name:&quot;测试-1&quot;</div><div class="line">          ]</div><div class="line">      &#125;</div><div class="line">      app_two &#123;</div><div class="line">          applicationId &quot;com.example.app2&quot;</div><div class="line">          manifestPlaceholders = [</div><div class="line">                  app_name:&quot;测试-2&quot;</div><div class="line">          ]</div><div class="line">      &#125;</div><div class="line">      app_three &#123;</div><div class="line">          applicationId &quot;com.example.app3&quot;</div><div class="line">          manifestPlaceholders = [</div><div class="line">                  app_name:&quot;测试-3&quot;</div><div class="line">          ]</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>是不是感觉这个方法很眼熟？<br>没错就是多渠道打包的地方，通过添加这段代码后需要用到gradle面板进行打包，得到app_one 通过查看包名发现它的包名为 <code>com.example.app1</code> 显示的名称也为 <code>测试-1</code>，app_two 与 app_three 效果等同，至此已经完成多包名打包，且通过同一份代码打出了不同包名、不同名称的三个应用，而需求也达到了。</p><p>可能有的朋友会问如果还需要其他的渠道包怎么办，如果有10的渠道而又要打包两个不同的应用那岂不是要写20个类似于app_one的东西，那不是要很麻烦？没错我正好也碰到了这种情况，经过多次研究测试发现并没有那么麻烦，只需设定一个默认的包名、应用名即可，废话不多说，直接贴代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">       if (PACKAGE == &quot;one&quot;) &#123;</div><div class="line">           applicationId &quot;com.example.app1&quot;</div><div class="line">           manifestPlaceholders = [</div><div class="line">                   app_name:&quot;测试-1&quot;</div><div class="line">           ]</div><div class="line">       &#125; else &#123;</div><div class="line">           applicationId &quot;com.example.app2&quot;</div><div class="line">           manifestPlaceholders = [</div><div class="line">                   app_name:&quot;测试-2&quot;</div><div class="line">           ]</div><div class="line">       &#125;</div><div class="line">       minSdkVersion 14</div><div class="line">       targetSdkVersion 23</div><div class="line">       versionCode 1</div><div class="line">       versionName &quot;1.0&quot;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   productFlavors &#123;</div><div class="line">       app_one &#123;&#125;</div><div class="line">       app_two &#123;&#125;</div><div class="line">       app_three &#123;&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>嗯，就是这样，在defaultConfig里面设置一个默认的包名与应用名就可以了。</p><p>好了，到了这一步我们就要用到另一个神奇的文件了</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-e297ef08da09dbd1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工程目录下配置文件"></p><p>看看你的工程根目录下得这个东西，没错就是它，这里我设置了一个字段“PACKAGE”，即告诉Studio我想要什么包，到这里相信大家也就明白我写的判断的目的了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PACKAGE=one</div></pre></td></tr></table></figure><p>只要通过修改这一字段为“one”，然后通过打包后就可以得到三个“测试-1”的app_one、app_two、app_three的apk文件了，同理将其修改为其他字段即可打出其他包名、应用名的应用了。<br>但是转到本人公司项目后发现这种方法竟然失灵了，即修改 properties 文件内的字段后得不到我想要的包，经过探索发现可能是与项目工程的大小有关，改完重启后就可以了。<br>当然还有另一个最重要的地方</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    package=&quot;com.example.morepackagenametest&quot;&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=&quot;true&quot;</div><div class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">        android:label=&quot;$&#123;app_name&#125;&quot;</div><div class="line">        android:supportsRtl=&quot;true&quot;</div><div class="line">        android:theme=&quot;@style/AppTheme&quot;&gt;</div><div class="line">        &lt;activity android:name=&quot;.MainActivity&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line"></div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line"></div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure><p>不同服务器地址以生成不同安装包方法类似，我这里不细说，有问题请留言</p><p>就是这里了，即之前定义的名字赋给应用了，在这里大家要注意一下在该项目的其他 model 内的清单文件里最好不要写  <code>android：label</code> 这句了，否则会报错的，至于是什么错一眼就可以看到了，当然如果报错了有两个方法：</p><ol><li>删掉其他 model 内清单文件下<code>application</code>的 <code>label</code> 属性</li><li>通过在 <code>application</code> 下添加 <code>tools:replace=&quot;android:label&quot;</code> 属性解决</li></ol><p>好了，打完收工。期待大神的批评指导。</p><ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>此文同事编写，此后会增加不同服务器地址以生成不同安装包的demo</p><p>原文：<a href="http://blog.csdn.net/qq_33673284/article/details/52875696" target="_blank" rel="external">http://blog.csdn.net/qq_33673284/article/details/52875696</a></p><p>最后附上资源下载地址  <a href="http://download.csdn.net/detail/qq_33673284/9659262" target="_blank" rel="external">Android 多包名打包应用</a>  供各位参考</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Android-Gradle-相同应用多包名打包，实现测试发布包分离
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="Gradle" scheme="http://quanke.name/tags/Gradle/"/>
    
      <category term="Android多渠道打包" scheme="http://quanke.name/tags/android-pg/"/>
    
  </entry>
  
  <entry>
    <title>一个老司机工程师整理的自动化测试资料</title>
    <link href="http://quanke.name/posts/16982/"/>
    <id>http://quanke.name/posts/16982/</id>
    <published>2017-02-22T16:05:15.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><h4 id="Python教程"><a href="#Python教程" class="headerlink" title="Python教程"></a>Python教程</h4><hr><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000</a></p><h4 id="Appium："><a href="#Appium：" class="headerlink" title="Appium："></a>Appium：</h4><p><a href="http://appium.io/slate/en/master/#" target="_blank" rel="external">http://appium.io/slate/en/master/#</a></p><p>Appium 中文 Appium API 文档<br><a href="https://testerhome.com/topics/3144" target="_blank" rel="external">https://testerhome.com/topics/3144</a></p><p>Appium移动自动化测试（虫师写的系列，质量高）<br><a href="http://www.cnblogs.com/fnng/p/4540731.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/4540731.html</a></p><p>Robot Framework +Appium的简单教程及实例<br><a href="http://blog.csdn.net/xyh421/article/details/52119872" target="_blank" rel="external">http://blog.csdn.net/xyh421/article/details/52119872</a></p><p>Python + Appium+ IOS自动化测试<br><a href="http://blog.csdn.net/temanm/article/details/49641133" target="_blank" rel="external">http://blog.csdn.net/temanm/article/details/49641133</a></p><p>Saucelabs+Java+TestNG+Appium+Maven+Git+Jenkins+ReportNG for Android 自动化测试<br><a href="http://blog.csdn.net/wanglin_lin/article/details/51931728" target="_blank" rel="external">http://blog.csdn.net/wanglin_lin/article/details/51931728</a></p><h4 id="Selenium-2"><a href="#Selenium-2" class="headerlink" title="Selenium 2"></a>Selenium 2</h4><hr><p>Selenium 2 入门<br><a href="http://www.ibm.com/developerworks/cn/web/wa-selenium2/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/web/wa-selenium2/</a></p><h4 id="Robot-Framework自动化测试"><a href="#Robot-Framework自动化测试" class="headerlink" title="Robot Framework自动化测试"></a>Robot Framework自动化测试</h4><hr><p>Robot Framework自动化测试（一）—第一个脚本<br><a href="http://www.cnblogs.com/fnng/p/3871712.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/3871712.html</a></p><p>Robot Framework自动化测试 —视频与教程免费分享（里面有 <code>PDF</code> 质量非常高）<br><a href="http://www.cnblogs.com/fnng/p/4333977.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/4333977.html</a></p><p>Jenkins+robotframework+svn持续集成环境配置<br><a href="http://lijunwei1228ok.blog.163.com/blog/static/97383797201407113453672/" target="_blank" rel="external">http://lijunwei1228ok.blog.163.com/blog/static/97383797201407113453672/</a></p><p>这个是一个程序员学习自动化测试的一个过程和资料，之后会有一些原创内容，欢迎关注</p><pre><code>如果你想零基础开始 从入门到精通 学习软件测试，建议花几块钱买视频教程</code></pre><p><a href="https://item.taobao.com/item.htm?id=544901106180" target="_blank" rel="external">https://item.taobao.com/item.htm?id=544901106180</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Python教程&quot;&gt;&lt;a href=&quot;#Python教程&quot; clas
      
    
    </summary>
    
      <category term="自动化测试" scheme="http://quanke.name/categories/autotest/"/>
    
    
      <category term="自动化测试" scheme="http://quanke.name/tags/autotest/"/>
    
      <category term="软件测试" scheme="http://quanke.name/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>APP版本管理SDK项目实战-准备篇</title>
    <link href="http://quanke.name/posts/47009/"/>
    <id>http://quanke.name/posts/47009/</id>
    <published>2016-10-26T12:42:19.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>因为友盟APP版本管理服务关闭（这是官方通知：<a href="http://bbs.umeng.com/thread-14590-1-1.html" target="_blank" rel="external">http://bbs.umeng.com/thread-14590-1-1.html</a> ），我计划做一个类似友盟的APP版本管理的功能，开放SDK，方便大家使用，我会把开发过程的思路分享给大家。</p><h4 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h4><p>版本管理项目我觉得对于所有的APP都是需要的，前期希望能做到和友盟一样。支持自动更新、手动更新、静默更新、强制更新、断点续传、忽略版本，服务端开放RESTFul的API，支持WEB管理页面，文件存储对接七牛，之后会支持各种存储</p><p>整个项目会涉及到API设计、移动端SDK开发、服务端开发、服务器选型、我打算全部自己一个人搞定</p><p>API我打算采用RESTFul架构，使用swagger在线调试API，分别用POST、PUT、GET、DELETE方法对资源做CURD操作。使用RESTFul的难点在于如何定义好各种资源的表述，即URI的定义。</p><p>SDK开发则打算第一版只用原生实现，优先Android SDK开发，之后再开发IOS SDK。</p><p>服务端开发准备使用最经典的SSM，数据库使用最最最经典的MySQL。</p><p>WEB管理后台使用Bootstrap响应式后台管理系统meadmin模板</p><p>服务器先自己本地开发，之后考虑阿里云或者其他。</p><h4 id="功能需求整理："><a href="#功能需求整理：" class="headerlink" title="功能需求整理："></a>功能需求整理：</h4><h5 id="SDK"><a href="#SDK" class="headerlink" title="SDK:"></a>SDK:</h5><ul><li>自动更新</li><li>手动更新</li><li>静默更新</li><li>强制更新</li><li>断点续传</li><li>忽略版本</li></ul><h5 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h5><ul><li>web管理</li><li>七牛存储</li><li>多个APP管理</li><li>渠道包支持</li><li>统计</li></ul><h4 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h4><p>因为是SDK，管理使用模板，所以没有原型设计，功能确定好，就可以设计API了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为友盟APP版本管理服务关闭（这是官方通知：&lt;a href=&quot;http://
      
    
    </summary>
    
      <category term="项目实战" scheme="http://quanke.name/categories/project/"/>
    
    
      <category term="SDK" scheme="http://quanke.name/tags/SDK/"/>
    
      <category term="Android" scheme="http://quanke.name/tags/Android/"/>
    
      <category term="JavaEE" scheme="http://quanke.name/tags/JavaEE/"/>
    
      <category term="IOS" scheme="http://quanke.name/tags/IOS/"/>
    
      <category term="Spring Boot" scheme="http://quanke.name/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Android DownloadManager ERROR_UNKNOWN 在API 17 巨坑完美解决</title>
    <link href="http://quanke.name/posts/42104/"/>
    <id>http://quanke.name/posts/42104/</id>
    <published>2016-10-26T12:36:20.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>现在做了一个下载，为了兼容性直接使用Android Sdk 自带的 <a href="https://developer.android.com/reference/android/app/DownloadManager.html" target="_blank" rel="external">DownloadManager</a> 开发，在其他手机上都是OK，只有在有一台vivo上不行。</p><p>我尝试使用vivo系统浏览器去下载这个链接，也是OK的，这个排除了网络问题和系统下载的bug的问题。</p><p>尝试去找错误给我返回一个<code>ERROR_UNKNOWN</code>,完全SB了，此路不通。</p><p>尝试换一个链接去下载，居然也是OK的，所以确定了是链接的问题，链接有什么问题？我对比了一下，除了下载失败链接里包含了中括号<code>[]</code>,其他也没有什么不一样的，所以我尝试着使用<code>%5B</code>、<code>%5D</code> 替换 <code>[]</code>,居然好了。这也太奇葩了吧。。。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url = url.replace(&quot;[&quot;,&quot;%5B&quot;).replace(&quot;]&quot;,&quot;%5D&quot;);</div></pre></td></tr></table></figure><p>之后我去Google了一下，搞明白了，原来Android系统在18之前有这么一个问题，之后修复了。</p><p>最终解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(Build.VERSION.SDK_INT&lt;=Build.VERSION_CODES.JELLY_BEAN_MR2)&#123;</div><div class="line">            uri = uri.replace(&quot;[&quot;,&quot;%5B&quot;).replace(&quot;]&quot;,&quot;%5D&quot;);</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>参考：</p><p><a href="http://stackoverflow.com/questions/37976748/downloadmanager-fails-with-error-unknown-on-api-17" target="_blank" rel="external">http://stackoverflow.com/questions/37976748/downloadmanager-fails-with-error-unknown-on-api-17</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在做了一个下载，为了兼容性直接使用Android Sdk 自带的 &lt;a hr
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio Service AIDL 详解</title>
    <link href="http://quanke.name/posts/52572/"/>
    <id>http://quanke.name/posts/52572/</id>
    <published>2016-07-22T15:35:30.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>公司产品之前IM这块存在很多问题，消息到达率低，加上协议上有些问题，丢消息频繁，所以需要重构IM，AIDL不能解决以上问题。好吧！那AIDL可以解决什么问题？什么是AIDL？</p><h3 id="什么是AIDL？"><a href="#什么是AIDL？" class="headerlink" title="什么是AIDL？"></a>什么是AIDL？</h3><p><code>AIDL</code>是 <code>Android Interface definition language</code>的缩写，它是一种<code>Android</code>内部进程通信接口的描述语言，通过它我们可以定义进程间的通信接口</p><h3 id="AIDL可以解决什么问题？"><a href="#AIDL可以解决什么问题？" class="headerlink" title="AIDL可以解决什么问题？"></a>AIDL可以解决什么问题？</h3><ul><li>可以实现多个应用程序共享同一个Service的功能，比如：IM服务可以提供给多个APP使用，先在推送基本都是采取这种方案</li><li>可以跨进程调用服务里的方法</li></ul><h3 id="Android-Studio-AIDL-实战"><a href="#Android-Studio-AIDL-实战" class="headerlink" title="Android Studio AIDL 实战"></a>Android Studio AIDL 实战</h3><p>大部分文章介绍都是在eclipse下介绍的，现在 Android Studio 作为开发工具比较普及了，所以我在Android Studio 下介绍（其实区别不大）。</p><p>言归正传，我们需要使用Android Studio实现一个远程Service，并且建立AIDL进行通信。</p><h4 id="搭建了简单的Service框架"><a href="#搭建了简单的Service框架" class="headerlink" title="搭建了简单的Service框架"></a>搭建了简单的Service框架</h4><p>1.继承Service</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.aidldemo;</div><div class="line"></div><div class="line">import android.app.Service;</div><div class="line">import android.content.Intent;</div><div class="line">import android.os.IBinder;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> *</div><div class="line"> * Created by http://quanke.name on 16/7/23.</div><div class="line"> */</div><div class="line">public class PushService extends Service &#123;</div><div class="line">    public PushService() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return new LibHandler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onUnbind(Intent intent) &#123;</div><div class="line">        return super.onUnbind(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.在AndroidManifest.xml里注册 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">          package=&quot;name.quanke.aidldemo&quot;&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">            android:allowBackup=&quot;true&quot;</div><div class="line">            android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">            android:label=&quot;@string/app_name&quot;</div><div class="line">            android:name=&quot;.App&quot;</div><div class="line">            android:supportsRtl=&quot;true&quot;</div><div class="line">            android:theme=&quot;@style/AppTheme&quot;&gt;</div><div class="line">        &lt;activity android:name=&quot;.MainActivity&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</div><div class="line"></div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line"></div><div class="line">        &lt;service</div><div class="line">                android:name=&quot;.PushService&quot;</div><div class="line">                android:enabled=&quot;true&quot;</div><div class="line">                android:process=&quot;:push&quot;</div><div class="line">                android:exported=&quot;true&quot;&gt;</div><div class="line">        &lt;/service&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line"></div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure><h4 id="建立AIDL"><a href="#建立AIDL" class="headerlink" title="建立AIDL"></a>建立AIDL</h4><h5 id="1-创建AIDL文件夹"><a href="#1-创建AIDL文件夹" class="headerlink" title="1.创建AIDL文件夹"></a>1.创建AIDL文件夹</h5><img src="/posts/52572/1.png" title="1.创建AIDL文件夹"><h5 id="2-创建AIDL文件"><a href="#2-创建AIDL文件" class="headerlink" title="2.创建AIDL文件"></a>2.创建AIDL文件</h5><img src="/posts/52572/2.png" title="2.创建AIDL文件"><h5 id="3-编写AIDL文件"><a href="#3-编写AIDL文件" class="headerlink" title="3.编写AIDL文件"></a>3.编写AIDL文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// IHandler.aidl</div><div class="line">package name.quanke.aidldemo;</div><div class="line"></div><div class="line">// Declare any non-default types here with import statements</div><div class="line"></div><div class="line">interface IHandler &#123;</div><div class="line">    void connect();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="4-AIDL文件-生成接口"><a href="#4-AIDL文件-生成接口" class="headerlink" title="4.AIDL文件 生成接口"></a>4.AIDL文件 生成接口</h5><img src="/posts/52572/4.png" title="4.AIDL文件 生成接口"><p>生成后的样子</p><img src="/posts/52572/3.png" title="4.AIDL文件 生成后的样子"><h5 id="5-编写客户端-ServiceConnection"><a href="#5-编写客户端-ServiceConnection" class="headerlink" title="5.编写客户端 ServiceConnection"></a>5.编写客户端 ServiceConnection</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.aidldemo;</div><div class="line"></div><div class="line">import android.app.Application;</div><div class="line">import android.content.ComponentName;</div><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line">import android.content.ServiceConnection;</div><div class="line">import android.os.IBinder;</div><div class="line">import android.os.RemoteException;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by quanke on 16/7/23.</div><div class="line"> */</div><div class="line">public class PushManager &#123;</div><div class="line"></div><div class="line">    private static final String TAG = &quot;PushManager.class&quot;;</div><div class="line">    private IHandler iHandler;</div><div class="line"></div><div class="line">    private static PushManager ourInstance = new PushManager();</div><div class="line"></div><div class="line">    public static PushManager getInstance() &#123;</div><div class="line">        return ourInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private PushManager() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void init(Application app)&#123;</div><div class="line"></div><div class="line">        Intent binderIntent = new Intent(app,PushService.class);</div><div class="line">        app.bindService(binderIntent, serviceConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void connect()&#123;</div><div class="line">        try &#123;</div><div class="line">            //通过AIDL远程调用</div><div class="line">            Log.d(TAG,&quot;++start Remote++&quot;);</div><div class="line">            iHandler.connect();</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private ServiceConnection serviceConnection = new ServiceConnection() &#123;</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">            iHandler = IHandler.Stub.asInterface(service);</div><div class="line">            //连接成功调动</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceDisconnected(ComponentName name) &#123;</div><div class="line">            //断开连接调用</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="6-编写服务端实现connect方法"><a href="#6-编写服务端实现connect方法" class="headerlink" title="6.编写服务端实现connect方法"></a>6.编写服务端实现connect方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.aidldemo;</div><div class="line"></div><div class="line">import android.os.IBinder;</div><div class="line">import android.os.RemoteException;</div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">/**</div><div class="line"> *</div><div class="line"> * Created by quanke on 16/7/23.</div><div class="line"> */</div><div class="line">public class LibHandler extends IHandler.Stub&#123;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void connect() throws RemoteException &#123;</div><div class="line">        Log.d(&quot;&quot;,&quot;connect()&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder asBinder() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上实现了简单的连接，接下来我们实现传递自定义类型</p><h4 id="传递自定义的类型"><a href="#传递自定义的类型" class="headerlink" title="传递自定义的类型"></a>传递自定义的类型</h4><p>AIDL默认支持的类型包括Java基本类型（int、long、boolean等），和（String、List、Map、CharSequence），如果要传递自定义的类型需要实现android.os.Parcelable接口。自己写了一个实体类public class Message implements Parcelable。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.aidldemo.model;</div><div class="line"></div><div class="line">import android.os.Parcel;</div><div class="line">import android.os.Parcelable;</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * Created by quanke on 16/7/23.</div><div class="line"> */</div><div class="line">public class Message implements Parcelable &#123;</div><div class="line">    private long id;</div><div class="line">    private String content;</div><div class="line"></div><div class="line"></div><div class="line">    public long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setId(long id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getContent() &#123;</div><div class="line">        return content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContent(String content) &#123;</div><div class="line">        this.content = content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Message&#123;&quot; +</div><div class="line">                &quot;id=&quot; + id +</div><div class="line">                &quot;, content=&apos;&quot; + content + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int describeContents() &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">        dest.writeLong(this.id);</div><div class="line">        dest.writeString(this.content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Message() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected Message(Parcel in) &#123;</div><div class="line">        this.id = in.readLong();</div><div class="line">        this.content = in.readString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static final Creator&lt;Message&gt; CREATOR = new Creator&lt;Message&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public Message createFromParcel(Parcel source) &#123;</div><div class="line">            return new Message(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Message[] newArray(int size) &#123;</div><div class="line">            return new Message[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>修改IHandler</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// IHandler.aidl</div><div class="line">package name.quanke.aidldemo;</div><div class="line"></div><div class="line">// Declare any non-default types here with import statements</div><div class="line"></div><div class="line">import name.quanke.aidldemo.model.Message;</div><div class="line"></div><div class="line">interface IHandler &#123;</div><div class="line">    void connect();</div><div class="line"></div><div class="line">    void sendMessage(Message message);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译项目，报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/Users/quanke/Dev/android/src/AIDLDemo/app/src/main/aidl/name/quanke/aidldemo/IHandler.aidl</div><div class="line">Error:(6) couldn&apos;t find import for class name.quanke.aidldemo.model.Message</div><div class="line">Error:Execution failed for task &apos;:app:compileDebugAidl&apos;.</div><div class="line">&gt; java.lang.RuntimeException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Users/quanke/Dev/android/tools/android-sdks/build-tools/23.0.3/aidl&apos;&apos; finished with non-zero exit value 1</div><div class="line">Information:BUILD FAILED</div></pre></td></tr></table></figure><p>因为自定义类型不仅要定义实现android.os.Parcelable接口的类，还得为该实现类定义一个aidl文件，如下：</p><img src="/posts/52572/5.png" title="自定义类aidl文件"><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// IHandler.aidl</div><div class="line">package name.quanke.aidldemo.model;</div><div class="line"></div><div class="line">// Declare any non-default types here with import statements</div><div class="line"></div><div class="line">import name.quanke.aidldemo.model.Message;</div><div class="line"></div><div class="line">parcelable Message ;</div></pre></td></tr></table></figure><blockquote><p><code>切记</code> 自定类型aidl文件名字、路径需要和自定义类名字、路径保持一致，</p></blockquote><p>编译项目，还是报错</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">parameter 1: &apos;Message message&apos; can be an out parameter, so you must declare it as in, out or inout.</div></pre></td></tr></table></figure><p><code>AIDL</code>不是 Java。它是真的很接近，但它不是 Java。</p><p>Java 参数没有方向的概念，AIDL 参数有方向，参数可以从客户端传到服务端，再返回来。</p><p>如果<code>sendMessage</code>方法的<code>message</code>参数是纯粹的输入参数–这意味着是从客户端到服务器的数据，你需要在AIDL声明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void sendMessage(in Message message);</div></pre></td></tr></table></figure><p>如果<code>sendMessage</code>方法的<code>message</code>参数是纯粹的输出-这意味着它的数据是通过从服务器到客户端，使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void sendMessage(out Message message);</div></pre></td></tr></table></figure><p>如果<code>sendMessage</code>方法的<code>message</code>参数是输入也是输出-客户端的值在服务可能会修改，使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void sendMessage(inout Message message);</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Android Studio Service AIDL 详解 就到这里，现在应该可以使用AIDL实现想要的功能了，实现简答的AIDL很简单，主要是在自定义类型的时候，有几个坑注意就好。</p><p><code>源码地址：</code> <a href="https://github.com/quanke/AIDLDemo.git" target="_blank" rel="external">https://github.com/quanke/AIDLDemo.git</a> </p><blockquote><p>有什么问题欢迎留言。</p><p>如果喜欢请关注我，赞我，来抚平我虚荣的心</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公司产品之前IM这块存在很多问题，消息到达率低，加上协议上有些问题，丢消息频繁
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>完美解决 Android 6 java.lang.AbstractMethodError</title>
    <link href="http://quanke.name/posts/60800/"/>
    <id>http://quanke.name/posts/60800/</id>
    <published>2016-07-19T13:55:13.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>在Android Marshmallow (6.0)中有一个异常，异常信息中居然没有和APP包相关的东西，感觉这是Android SDK的一个坑</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.lang.AbstractMethodError: abstract method “int android.text.ParcelableSpan.getSpanTypeIdInternal()”</div></pre></td></tr></table></figure><p>Google一下，还真有人也遇到了同样的问题，看了半天也没有解决方案,只是解释了，为什么会有这个问题，大概就是在 Android 6.0 之后 <code>ParcelableSpan</code> 接口的 <code>getSpanTypeIdInternal</code> 和 <code>writeToParcelInternal</code> 方法是 <code>@hide</code> 标记了，多次提醒我们要看Google的文档，但是怎么解决呢？找另外的方法吧，此处不通。。。</p><p>既然不能实现<code>ParcelableSpan</code>接口了，那就换一种方式实现吧。</p><p>我换成继承<code>android.text.style.UnderlineSpan</code>类，居然可以了</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.utan.app.utantop;</div><div class="line"></div><div class="line">import android.os.Parcel;</div><div class="line">import android.text.style.UnderlineSpan;</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * Created by quanke.name on 2016/7/16.</div><div class="line"> * App Url:utantop.com</div><div class="line"> */</div><div class="line">public class UtanUnderlineSpan extends UnderlineSpan &#123;</div><div class="line">    public UtanUnderlineSpan() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public UtanUnderlineSpan(Parcel src) &#123;</div><div class="line">        super(src);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://medium.com/@numan1617/android-framework-classes-choose-wisely-2f8300f6c255#.3669g6u0m" target="_blank" rel="external">https://medium.com/@numan1617/android-framework-classes-choose-wisely-2f8300f6c255#.3669g6u0m</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Android Marshmallow (6.0)中有一个异常，异常信息中居
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>完美解决 java.lang.NoClassDefFoundError  R R 巨坑</title>
    <link href="http://quanke.name/posts/57394/"/>
    <id>http://quanke.name/posts/57394/</id>
    <published>2016-07-19T13:53:59.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><blockquote><p>此坑有点大，害我同事弄了一周没有搞定</p></blockquote><p>开始的时候是报另外一个错误，也是NoClassDefFoundError异常，但这个是因为包冲突的问题,删除掉一些包就好了。但是这个问题没有这么简单。</p><p>首先描述一下我们的场景吧：</p><p>我们做了一个<code>优谈TOP</code> APP，主要的逻辑代码是在一个单独的<code>android studio module</code> 实现的，这个主要是为了可以导入到公司其他APP里面，就是把<code>优谈TOP</code>当成sdk，嵌入到公司其他APP里，我们使用<code>优谈TOP</code>单独运行的时候没有一点问题，导入到另外要一个APP的时候，问题就出现了。</p><p>百度，Google搜了以大堆资料，都没有解决，最后在<code>stackoverflow</code>找到了一种方案。还真可以</p><p><code>stackoverflow</code> 连接 <a href="http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r" target="_blank" rel="external">http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r</a></p><blockquote><p>看了这个才知道，这是Dex超出方法数的限制问题，Dex达到极限时，会创建多个Dex文件，android Lollipop 没有处理，需要在应用中处理 。</p></blockquote><h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>在 <code>build.gradle</code> 中增加(非 <code>root</code> <code>build.gradle</code> )</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.android.support:multidex:1.0.0&apos;</div><div class="line">&#125;</div><div class="line">defaultConfig &#123;          </div><div class="line">    multiDexEnabled true</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>在AndroidManifest.xml增加</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;application</div><div class="line">        ...</div><div class="line">        android:name=&quot;android.support.multidex.MultiDexApplication&quot;&gt;</div><div class="line">        ...</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure><p>如果需要自己实现 <code>Application</code>,需要重写<code>attachBaseContext</code>方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import android.support.multidex.MultiDexApplication;</div><div class="line">import android.support.multidex.MultiDex;</div><div class="line"></div><div class="line">public class MyApplication extends MultiDexApplication &#123;</div><div class="line"> // ......</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void attachBaseContext(Context base) &#123;</div><div class="line">        super.attachBaseContext(base);</div><div class="line">        MultiDex.install(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import android.support.multidex.MultiDex;</div><div class="line">public class MyApplication extends Application &#123;</div><div class="line"> // ......</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void attachBaseContext(Context base) &#123;</div><div class="line">        super.attachBaseContext(base);</div><div class="line">        MultiDex.install(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考：<a href="https://developer.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="external">https://developer.android.com/tools/building/multidex.html#mdex-gradle</a> </p><p>这里记录一下没有解决我的问题的方案，也许你有用：</p><p><a href="http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r?noredirect=1&amp;lq=1" target="_blank" rel="external">http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r?noredirect=1&amp;lq=1</a></p><p><a href="http://stackoverflow.com/questions/27614538/crash-java-lang-noclassdeffounderror-android-support-v7-appcompat-rlayout" target="_blank" rel="external">http://stackoverflow.com/questions/27614538/crash-java-lang-noclassdeffounderror-android-support-v7-appcompat-rlayout</a></p><p><a href="http://stackoverflow.com/questions/9870995/android-java-lang-noclassdeffounderror" target="_blank" rel="external">http://stackoverflow.com/questions/9870995/android-java-lang-noclassdeffounderror</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;此坑有点大，害我同事弄了一周没有搞定&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
</feed>
